/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2021-08-11 17:43:03.071336
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51;
x0=IKcos(j[0]);
x1=IKsin(j[1]);
x2=IKsin(j[2]);
x3=IKcos(j[1]);
x4=IKcos(j[2]);
x5=IKcos(j[3]);
x6=IKsin(j[0]);
x7=IKsin(j[3]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=((1.0)*x5);
x13=((0.065)*x4);
x14=((0.0741)*x4);
x15=((0.0741)*x0);
x16=((1.0)*x7);
x17=((0.065)*x0);
x18=((1.0)*x6);
x19=((0.056)*x6);
x20=((0.065)*x5);
x21=((0.29061)*x6);
x22=((1.0)*x0);
x23=((0.056)*x0);
x24=(x5*x9);
x25=(x2*x3);
x26=(x0*x1);
x27=(x1*x2);
x28=(x1*x4);
x29=(x3*x4);
x30=(x1*x6);
x31=(x6*x7);
x32=(x5*x8);
x33=(x0*x16);
x34=(x0*x12);
x35=(x22*x27);
x36=(x18*x27);
x37=((((-1.0)*x27))+x29);
x38=(x25+x28);
x39=((((-1.0)*x25))+(((-1.0)*x28)));
x40=((((-1.0)*x35))+((x0*x29)));
x41=(((x29*x6))+(((-1.0)*x36)));
x42=(x35+(((-1.0)*x22*x29)));
x43=((((-1.0)*x18*x29))+x36);
x44=(x22*(((((-1.0)*x25))+(((-1.0)*x28)))));
x45=(x18*(((((-1.0)*x25))+(((-1.0)*x28)))));
x46=(x40*x7);
x47=(x43*x5);
x48=(x42*x5);
x49=(((x32*x39))+((x37*x9)));
x50=(((x8*((x31+x48))))+((x44*x9)));
x51=(((x8*(((((-1.0)*x33))+x47))))+((x45*x9)));
eerot[0]=(((x11*((((x5*x6))+x46))))+((x10*x50)));
eerot[1]=(((x44*x8))+((x9*(((((-1.0)*x12*x42))+(((-1.0)*x16*x6)))))));
eerot[2]=(((x10*(((((-1.0)*x12*x6))+(((-1.0)*x16*x40))))))+((x11*x50)));
IkReal x52=((1.0)*x25);
IkReal x53=((1.0)*x26);
eetrans[0]=(((x8*(((((-1.0)*x14*x53))+(((-1.0)*x15*x52))))))+((x9*(((((-0.0741)*x31))+(((-0.0741)*x48))))))+((x23*x27))+(((-0.205)*x26))+(((-0.29061)*x26*x4))+x23+(((-0.29061)*x0*x25))+((x8*((((x20*x42))+(((0.065)*x31))))))+((x9*(((((-1.0)*x13*x53))+(((-1.0)*x17*x52))))))+(((-1.0)*x23*x29)));
eerot[3]=(((x11*(((((-1.0)*x34))+((x41*x7))))))+((x10*x51)));
eerot[4]=(((x9*(((((-1.0)*x12*x43))+x33))))+((x45*x8)));
eerot[5]=(((x10*(((((-1.0)*x16*x41))+x34))))+((x11*x51)));
IkReal x54=((1.0)*x30);
IkReal x55=((1.0)*x21);
IkReal x56=(x25*x6);
eetrans[1]=(((x9*(((((-1.0)*x13*x54))+(((-0.065)*x56))))))+(((-1.0)*x25*x55))+((x19*x27))+((x8*((((x20*x43))+(((-1.0)*x17*x7))))))+(((-1.0)*x19*x29))+((x8*(((((-1.0)*x14*x54))+(((-0.0741)*x56))))))+x19+(((-1.0)*x28*x55))+(((-0.205)*x30))+((x9*(((((-0.0741)*x47))+((x15*x7)))))));
eerot[6]=(((x10*x49))+((x11*x38*x7)));
eerot[7]=(((x24*x38))+((x37*x8)));
eerot[8]=(((x11*x49))+((x10*x39*x7)));
eetrans[2]=((0.2833)+((x9*((((x13*x3))+(((-0.065)*x27))))))+(((0.29061)*x29))+(((-0.056)*x28))+(((-0.056)*x25))+((x32*(((((-1.0)*x1*x13))+(((-0.065)*x25))))))+(((-0.29061)*x27))+((x8*(((((-0.0741)*x27))+((x14*x3))))))+(((0.205)*x3))+((x24*((((x1*x14))+(((0.0741)*x25)))))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=((-1.0)*r02);
new_r02=r01;
new_px=((((-0.0741)*r01))+px);
new_r10=r10;
new_r11=((-1.0)*r12);
new_r12=r11;
new_py=((((-0.0741)*r11))+py);
new_r20=r20;
new_r21=((-1.0)*r22);
new_r22=r21;
new_pz=((-0.2833)+pz+(((-0.0741)*r21)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x57=((1.0)*px);
IkReal x58=((1.0)*pz);
IkReal x59=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x59))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x58)));
rxp0_2=((((-1.0)*r10*x57))+((py*r00)));
rxp1_0=((((-1.0)*r21*x59))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x58)));
rxp1_2=((((-1.0)*r11*x57))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x59)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x58)));
rxp2_2=((((-1.0)*r12*x57))+((py*r02)));
IkReal op[72], zeror[48];
int numroots;;
IkReal x60=(rxp2_2+(((-0.065)*r21)));
IkReal x61=((0.065)*r21);
IkReal x62=((0.112)*px);
IkReal x63=((0.58122)*npz);
IkReal x64=((0.00728)*r00);
IkReal x65=((0.006272)*r22);
IkReal x66=((0.112)*rxp2_1);
IkReal x67=((0.00728)*r11);
IkReal x68=((0.03254832)*r02);
IkReal x69=((1.0)*pp);
IkReal x70=((0.13)*npx);
IkReal x71=((0.112)*py);
IkReal x72=((0.112)*rxp2_0);
IkReal x73=((0.00728)*r10);
IkReal x74=((0.00728)*r01);
IkReal x75=((0.03254832)*r12);
IkReal x76=((0.01456)*r01);
IkReal x77=((0.26)*npy);
IkReal x78=((0.01456)*r10);
IkReal x79=((2.0)*rxp0_2);
IkReal x80=((0.224)*rxp0_1);
IkReal x81=((0.06509664)*r00);
IkReal x82=((0.012544)*r20);
IkReal x83=((1.16244)*npx);
IkReal x84=((0.06509664)*r10);
IkReal x85=((0.224)*rxp0_0);
IkReal x86=((0.448)*rxp1_1);
IkReal x87=((2.32488)*npy);
IkReal x88=((0.13019328)*r01);
IkReal x89=((0.025088)*r21);
IkReal x90=((0.13)*r20);
IkReal x91=((1.0)*rxp2_2);
IkReal x92=((0.01456)*r00);
IkReal x93=((0.01456)*r11);
IkReal x94=((-0.13)*r20);
IkReal x95=(rxp2_2+x61);
IkReal x96=(x93+(((-1.0)*x92)));
IkReal x97=((-4.0)*rxp1_2);
IkReal x98=((-2.0)*rxp0_2);
IkReal x99=(x85+(((-1.0)*x84)));
IkReal x100=((((-0.448)*rxp1_0))+(((0.13019328)*r11)));
IkReal x101=(x84+(((-1.0)*x85)));
IkReal x102=(x61+(((-1.0)*x91)));
IkReal x103=((-0.0529261721)+x67);
IkReal x104=((((-1.0)*x91))+(((-1.0)*x61)));
IkReal x105=(x93+x92);
IkReal x106=(x73+x71);
IkReal x107=(x74+x72);
IkReal x108=(x89+x87);
IkReal x109=(x62+x69);
IkReal x110=(x64+x69);
IkReal x111=(x66+x68);
IkReal x112=(x63+x65);
IkReal x113=(x88+x86);
IkReal x114=(x62+x64);
IkReal x115=(x70+x69);
IkReal x116=(x77+x78);
IkReal x117=(x75+x74);
IkReal x118=(x82+x83);
IkReal x119=(x80+x81);
IkReal x120=(x70+x64);
IkReal x121=(x70+x62);
IkReal x122=(x112+x111);
IkReal x123=((((-1.0)*x73))+(((-1.0)*x117))+x72+x71);
IkReal x124=((((-1.0)*x75))+x106+x107);
IkReal x125=((((-1.0)*x72))+(((-1.0)*x73))+x117+x71);
IkReal x126=((((-1.0)*x107))+x106+x75);
op[0]=x60;
op[1]=x60;
op[2]=x94;
op[3]=x94;
op[4]=x95;
op[5]=x95;
op[6]=((((-1.0)*x111))+(((-1.0)*x110))+x121+x112+x103);
op[7]=x123;
op[8]=((((-1.0)*x77))+x76+x78);
op[9]=x96;
op[10]=((-0.0529261721)+(((-1.0)*x111))+(((-1.0)*x115))+x112+x114+(((-1.0)*x67)));
op[11]=x124;
op[12]=x123;
op[13]=((-0.0529261721)+(((-1.0)*x109))+x122+x120+(((-1.0)*x67)));
op[14]=x96;
op[15]=((((-1.0)*x76))+(((-1.0)*x116)));
op[16]=x124;
op[17]=((((-1.0)*x109))+(((-1.0)*x120))+x122+x103);
op[18]=0;
op[19]=x60;
op[20]=0;
op[21]=x94;
op[22]=0;
op[23]=x95;
op[24]=x79;
op[25]=x79;
op[26]=x97;
op[27]=x97;
op[28]=x98;
op[29]=x98;
op[30]=((-0.0755586)+(((-1.0)*x119))+x118);
op[31]=x99;
op[32]=((((-1.0)*x108))+x113);
op[33]=x100;
op[34]=((-0.0755586)+(((-1.0)*x118))+x119);
op[35]=x101;
op[36]=x99;
op[37]=((-0.0755586)+x119+x118);
op[38]=x100;
op[39]=((((-1.0)*x108))+(((-1.0)*x113)));
op[40]=x101;
op[41]=((-0.0755586)+(((-1.0)*x118))+(((-1.0)*x119)));
op[42]=0;
op[43]=x79;
op[44]=0;
op[45]=x97;
op[46]=0;
op[47]=x98;
op[48]=x102;
op[49]=x102;
op[50]=x90;
op[51]=x90;
op[52]=x104;
op[53]=x104;
op[54]=((-0.0529261721)+(((-1.0)*x112))+(((-1.0)*x110))+x121+x111+(((-1.0)*x67)));
op[55]=x125;
op[56]=((((-1.0)*x116))+x76);
op[57]=x105;
op[58]=((((-1.0)*x112))+(((-1.0)*x115))+x111+x114+x103);
op[59]=x126;
op[60]=x125;
op[61]=((((-1.0)*x109))+(((-1.0)*x122))+x120+x103);
op[62]=x105;
op[63]=((((-1.0)*x76))+(((-1.0)*x77))+x78);
op[64]=x126;
op[65]=((-0.0529261721)+(((-1.0)*x109))+(((-1.0)*x120))+(((-1.0)*x122))+(((-1.0)*x67)));
op[66]=0;
op[67]=x102;
op[68]=0;
op[69]=x90;
op[70]=0;
op[71]=x104;
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j4array[16], cj4array[16], sj4array[16], j5array[16], cj5array[16], sj5array[16], j0array[16], cj0array[16], sj0array[16];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ij4 += 3)
{
IkReal htj4 = zeror[ij4+0], htj5 = zeror[ij4+1], htj0 = zeror[ij4+2];
if(isnan(htj4)||isnan(htj5)||isnan(htj0)){
continue;
}
j4array[numsolutions]=((2.0)*(atan(htj4)));
j5array[numsolutions]=((2.0)*(atan(htj5)));
j0array[numsolutions]=((2.0)*(atan(htj0)));
if(isinf(htj4)){
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
}
else{
IkReal x127=htj4*htj4;
CheckValue<IkReal> x128=IKPowWithIntegerCheck(((1.0)+x127),-1);
if(!x128.valid){
continue;
}
cj4array[numsolutions]=((x128.value)*(((1.0)+(((-1.0)*x127)))));
CheckValue<IkReal> x129=IKPowWithIntegerCheck(((1.0)+(htj4*htj4)),-1);
if(!x129.valid){
continue;
}
sj4array[numsolutions]=((2.0)*htj4*(x129.value));
}
if(isinf(htj5)){
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
}
else{
IkReal x130=htj5*htj5;
CheckValue<IkReal> x131=IKPowWithIntegerCheck(((1.0)+x130),-1);
if(!x131.valid){
continue;
}
cj5array[numsolutions]=((x131.value)*(((1.0)+(((-1.0)*x130)))));
CheckValue<IkReal> x132=IKPowWithIntegerCheck(((1.0)+(htj5*htj5)),-1);
if(!x132.valid){
continue;
}
sj5array[numsolutions]=((2.0)*htj5*(x132.value));
}
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x133=htj0*htj0;
CheckValue<IkReal> x134=IKPowWithIntegerCheck(((1.0)+x133),-1);
if(!x134.valid){
continue;
}
cj0array[numsolutions]=((x134.value)*(((1.0)+(((-1.0)*x133)))));
CheckValue<IkReal> x135=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x135.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x135.value));
}
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j4valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj4 = 16;
_nj5 = 1;
_nj0 = 1;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
_ij5[0] = 0; _ij5[1] = -1;
_ij0[0] = 0; _ij0[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( !j4valid[iij4] ) { continue; }
if( IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj5array[ij4]-cj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij4]-sj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj0array[ij4]-cj0array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij4]-sj0array[iij4]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j4valid[iij4]=false; _ij4[1] = iij4; _ij5[1] = 0; _ij0[1] = 0;  break; 
}
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

    j5 = j5array[ij4]; cj5 = cj5array[ij4]; sj5 = sj5array[ij4];

    j0 = j0array[ij4]; cj0 = cj0array[ij4]; sj0 = sj0array[ij4];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j3eval[3];
IkReal x136=((1.0)*cj5);
IkReal x137=(cj0*r21);
IkReal x138=(cj0*r20);
IkReal x139=((((-1.0)*cj4*r02))+((r01*sj4*sj5))+(((-1.0)*r00*sj4*x136)));
j3eval[0]=x139;
j3eval[1]=IKsign(x139);
j3eval[2]=((IKabs((((cj4*sj5*x137))+(((-1.0)*cj4*x136*x138))+((cj0*r22*sj4)))))+(IKabs((((sj5*x138))+((cj5*x137))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
IkReal x140=(cj4*sj0);
IkReal x141=((1.0)*cj5);
IkReal x142=(((r11*sj4*sj5))+(((-1.0)*r10*sj4*x141))+(((-1.0)*cj4*r12)));
j3eval[0]=x142;
j3eval[1]=IKsign(x142);
j3eval[2]=((IKabs((((r22*sj0*sj4))+(((-1.0)*r20*x140*x141))+((r21*sj5*x140)))))+(IKabs((((cj5*r21*sj0))+((r20*sj0*sj5))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x143=(((cj4*r22))+((cj5*r20*sj4))+(((-1.0)*r21*sj4*sj5)));
j3eval[0]=x143;
j3eval[1]=IKsign(x143);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x144=(((cj4*r22))+((cj5*r20*sj4))+(((-1.0)*r21*sj4*sj5)));
j3eval[0]=x144;
j3eval[1]=((IKabs((((r00*sj5))+((cj5*r01)))))+(IKabs(((((-1.0)*cj4*cj5*r00))+((r02*sj4))+((cj4*r01*sj5))))));
j3eval[2]=IKsign(x144);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x145=((1.0)*cj5);
IkReal x146=((((-1.0)*cj4*r02))+((r01*sj4*sj5))+(((-1.0)*r00*sj4*x145)));
j3eval[0]=x146;
j3eval[1]=IKsign(x146);
j3eval[2]=((IKabs((((cj4*r21*sj5))+((r22*sj4))+(((-1.0)*cj4*r20*x145)))))+(IKabs((((cj5*r21))+((r20*sj5))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x147=cj4*cj4;
IkReal x148=cj5*cj5;
IkReal x149=r10*r10;
IkReal x150=r11*r11;
IkReal x151=r12*r12;
IkReal x152=(cj5*r10);
IkReal x153=(r11*sj5);
IkReal x154=(r12*sj4);
IkReal x155=((2.0)*cj4);
IkReal x156=((1.0)*x149);
IkReal x157=(x148*x150);
IkReal x158=((((-1.0)*x156))+(((-2.0)*x152*x153))+(((-1.0)*x147*x148*x156))+(((-1.0)*x153*x154*x155))+(((-1.0)*x151))+(((-1.0)*x157))+((x148*x149))+((x147*x157))+((x147*x151))+((x152*x154*x155))+(((-1.0)*x147*x150))+(((2.0)*x147*x152*x153)));
j3eval[0]=x158;
j3eval[1]=((IKabs((((cj4*x152))+(((-1.0)*cj4*x153))+(((-1.0)*x154)))))+(IKabs((((cj5*r11))+((r10*sj5))))));
j3eval[2]=IKsign(x158);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x159=cj4*cj4;
IkReal x160=cj5*cj5;
IkReal x161=r10*r10;
IkReal x162=r11*r11;
IkReal x163=r12*r12;
IkReal x164=(cj5*r10);
IkReal x165=(r11*sj5);
IkReal x166=(r12*sj4);
IkReal x167=((2.0)*cj4);
IkReal x168=((1.0)*x161);
IkReal x169=(x160*x162);
CheckValue<IkReal> x170=IKPowWithIntegerCheck(IKsign((((x164*x166*x167))+(((-1.0)*x168))+(((-1.0)*x159*x160*x168))+(((-2.0)*x164*x165))+(((2.0)*x159*x164*x165))+(((-1.0)*x163))+(((-1.0)*x169))+(((-1.0)*x159*x162))+(((-1.0)*x165*x166*x167))+((x159*x163))+((x159*x169))+((x160*x161)))),-1);
if(!x170.valid){
continue;
}
CheckValue<IkReal> x171 = IKatan2WithCheck(IkReal((((cj4*x164))+(((-1.0)*cj4*x165))+(((-1.0)*x166)))),IkReal((((cj5*r11))+((r10*sj5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x171.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x170.value)))+(x171.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x172=IKcos(j3);
IkReal x173=IKsin(j3);
IkReal x174=(r12*sj4);
IkReal x175=((1.0)*sj5);
IkReal x176=((1.0)*x172);
IkReal x177=(cj5*x172);
IkReal x178=(cj4*x173);
IkReal x179=(sj5*x172);
IkReal x180=((1.0)*x173);
evalcond[0]=((((-1.0)*r22*sj4*x180))+((r20*x179))+((cj5*r20*x178))+((r21*x177))+(((-1.0)*r21*x175*x178)));
evalcond[1]=(((r00*x179))+(((-1.0)*r02*sj4*x180))+((r01*x177))+(((-1.0)*r01*x175*x178))+((cj5*r00*x178)));
evalcond[2]=((1.0)+(((-1.0)*r11*x175*x178))+((r10*x179))+((cj5*r10*x178))+(((-1.0)*x174*x180))+((r11*x177)));
evalcond[3]=((((-1.0)*x174*x176))+(((-1.0)*r10*x173*x175))+(((-1.0)*cj5*r11*x180))+(((-1.0)*cj4*r11*x172*x175))+((cj4*r10*x177)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x181=((12.0)*pz);
IkReal x182=((3.48732)*pz);
IkReal x183=(r21*sj5);
IkReal x184=((1.0510820652)*sj4);
IkReal x185=(cj5*r00);
IkReal x186=(cj5*r20);
IkReal x187=(cj4*r22);
IkReal x188=((3.48732)*sj4);
IkReal x189=((0.3503606884)*sj4);
IkReal x190=(cj4*r02);
IkReal x191=(r01*sj5);
IkReal x192=((1.16244)*sj4);
IkReal x193=((0.78)*x183);
IkReal x194=((0.04368)*x185);
IkReal x195=((0.2266758)*x183);
IkReal x196=(sj4*x191);
IkReal x197=((0.672)*x196);
IkReal x198=(x183*x188);
IkReal x199=(x183*x184);
IkReal x200=(x199+x195+x194+x182);
IkReal x201=(x198+x193+x197+x181);
IkReal x202=((((0.672)*px))+((x184*x186))+(((0.2266758)*x186))+(((0.04368)*x191))+(((1.0510820652)*x187)));
IkReal x203=(((x186*x188))+(((0.672)*sj4*x185))+(((0.672)*x190))+(((3.48732)*x187))+(((0.78)*x186)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((0.82)+(((-1.0)*x203))+x201)))))+(((2.72212543554007)*(IKabs(((0.2759322)+(((-1.0)*x202))+x200)))))+(((2.72212543554007)*(IKabs(((0.2508442)+(((-0.01456)*x191))+(((-1.0)*x186*x189))+(((-0.3503606884)*x187))+(((0.01456)*x185))+(((-0.0755586)*x186))+(((-0.224)*px))+(((0.0755586)*x183))+((x183*x189))+(((1.16244)*pz)))))))+(((2.72212543554007)*(IKabs(((-0.82)+(((-1.0)*x203))+x201)))))+(((2.72212543554007)*(IKabs(((-0.2006682)+(((-1.0)*x202))+x200)))))+(((2.72212543554007)*(IKabs(((0.82)+(((0.224)*x196))+(((-0.224)*sj4*x185))+(((4.0)*pz))+(((-1.0)*x186*x192))+(((0.26)*x183))+(((-0.26)*x186))+(((-0.224)*x190))+(((-1.16244)*x187))+((x183*x192))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x204=((12.0)*pz);
IkReal x205=((4.0)*pz);
IkReal x206=(cj5*sj4);
IkReal x207=(cj4*r22);
IkReal x208=(r21*sj5);
IkReal x209=(cj5*r20);
IkReal x210=(cj4*r02);
IkReal x211=((0.78)*x208);
IkReal x212=((0.26)*x208);
IkReal x213=(r01*sj4*sj5);
IkReal x214=((0.672)*x213);
IkReal x215=((3.48732)*sj4*x208);
IkReal x216=((1.16244)*sj4*x208);
IkReal x217=((0.224)*x213);
IkReal x218=(x211+x214+x215+x204);
IkReal x219=(x212+x216+x217+x205);
IkReal x220=((((0.672)*r00*x206))+(((3.48732)*r20*x206))+(((0.672)*x210))+(((0.78)*x209))+(((3.48732)*x207)));
IkReal x221=((((1.16244)*x207))+(((0.224)*r00*x206))+(((1.16244)*r20*x206))+(((0.26)*x209))+(((0.224)*x210)));
op[0]=((0.82)+x219+(((-1.0)*x221)));
op[1]=0;
op[2]=((0.82)+x218+(((-1.0)*x220)));
op[3]=0;
op[4]=((-0.82)+x218+(((-1.0)*x220)));
op[5]=0;
op[6]=((-0.82)+x219+(((-1.0)*x221)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x222=((3.48732)*pz);
IkReal x223=((1.16244)*pz);
IkReal x224=((0.224)*px);
IkReal x225=(r21*sj5);
IkReal x226=((1.0510820652)*sj4);
IkReal x227=(cj5*r00);
IkReal x228=(cj5*r20);
IkReal x229=(cj4*r22);
IkReal x230=((0.3503606884)*sj4);
IkReal x231=(r01*sj5);
IkReal x232=((0.0755586)*x225);
IkReal x233=((0.01456)*x227);
IkReal x234=((0.04368)*x227);
IkReal x235=((0.2266758)*x225);
IkReal x236=((0.3503606884)*x229);
IkReal x237=((0.0755586)*x228);
IkReal x238=((0.01456)*x231);
IkReal x239=(x225*x226);
IkReal x240=(x225*x230);
IkReal x241=(x228*x230);
IkReal x242=(x223+x232+x233+x240);
IkReal x243=(x222+x239+x234+x235);
IkReal x244=((((0.672)*px))+(((0.04368)*x231))+(((0.2266758)*x228))+(((1.0510820652)*x229))+((x226*x228)));
IkReal x245=(x224+x238+x236+x237+x241);
j1evalpoly[0]=((-0.2257562)+(((htj1*htj1)*(((-0.2006682)+x243+(((-1.0)*x244))))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.2508442)+x242+(((-1.0)*x245))))))+(((-0.18368)*(htj1*htj1*htj1)))+x242+(((htj1*htj1*htj1*htj1)*(((0.2759322)+x243+(((-1.0)*x244))))))+(((-0.09184)*(htj1*htj1*htj1*htj1*htj1)))+(((-1.0)*x245))+(((-0.09184)*htj1)));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x246=((1.0)*r00);
IkReal x247=((1.0)*sj1);
IkReal x248=(cj5*sj4);
IkReal x249=(cj4*r22);
IkReal x250=(cj4*r02);
IkReal x251=((1.0)*cj1);
IkReal x252=(r01*sj4*sj5);
IkReal x253=(cj1*x248);
IkReal x254=(r21*sj4*sj5);
if( IKabs(((((-1.0)*x250*x251))+((cj1*x252))+(((-1.0)*r20*x247*x248))+((sj1*x254))+(((-1.0)*x246*x253))+(((-1.0)*x247*x249)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x246*x248))+((r20*x253))+(((-1.0)*x251*x254))+((sj1*x252))+((cj1*x249))+(((-1.0)*x247*x250)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x250*x251))+((cj1*x252))+(((-1.0)*r20*x247*x248))+((sj1*x254))+(((-1.0)*x246*x253))+(((-1.0)*x247*x249))))+IKsqr(((((-1.0)*sj1*x246*x248))+((r20*x253))+(((-1.0)*x251*x254))+((sj1*x252))+((cj1*x249))+(((-1.0)*x247*x250))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x250*x251))+((cj1*x252))+(((-1.0)*r20*x247*x248))+((sj1*x254))+(((-1.0)*x246*x253))+(((-1.0)*x247*x249))), ((((-1.0)*sj1*x246*x248))+((r20*x253))+(((-1.0)*x251*x254))+((sj1*x252))+((cj1*x249))+(((-1.0)*x247*x250))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x255=IKcos(j2);
IkReal x256=IKsin(j2);
IkReal x257=((0.29061)*sj1);
IkReal x258=(cj5*r00);
IkReal x259=((1.0)*cj3);
IkReal x260=(r01*sj5);
IkReal x261=(cj3*cj4);
IkReal x262=(r21*sj5);
IkReal x263=((1.0)*cj5);
IkReal x264=((1.0)*cj4);
IkReal x265=(cj5*r20);
IkReal x266=(cj1*x255);
IkReal x267=(cj1*x256);
IkReal x268=(sj1*x256);
IkReal x269=(sj1*x255);
IkReal x270=((1.0)*sj3*sj5);
IkReal x271=((1.0)*x268);
evalcond[0]=((((-1.0)*r20*sj4*x263))+x266+(((-1.0)*x271))+(((-1.0)*r22*x264))+((sj4*x262)));
evalcond[1]=((((-1.0)*x269))+(((-1.0)*x267))+(((-1.0)*sj4*x258))+(((-1.0)*r02*x264))+((sj4*x260)));
evalcond[2]=((((-1.0)*cj4*x259*x262))+(((-1.0)*r21*sj3*x263))+(((-1.0)*r22*sj4*x259))+x267+x269+((x261*x265))+(((-1.0)*r20*x270)));
evalcond[3]=((((-1.0)*cj4*x259*x260))+((x258*x261))+x266+(((-1.0)*r00*x270))+(((-1.0)*r01*sj3*x263))+(((-1.0)*x271))+(((-1.0)*r02*sj4*x259)));
evalcond[4]=((((0.205)*cj1))+(((-1.0)*x256*x257))+(((0.29061)*x266))+(((-1.0)*pz))+(((-0.065)*x262))+(((0.065)*x265))+(((-0.056)*x269))+(((-0.056)*x267)));
evalcond[5]=((0.056)+(((-1.0)*x255*x257))+(((0.065)*x258))+(((0.056)*x268))+(((-0.205)*sj1))+(((-1.0)*px))+(((-0.065)*x260))+(((-0.29061)*x267))+(((-0.056)*x266)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x272=((1.0)*cj5);
CheckValue<IkReal> x273 = IKatan2WithCheck(IkReal((((cj5*r21))+((r20*sj5)))),IkReal((((cj4*r21*sj5))+((r22*sj4))+(((-1.0)*cj4*r20*x272)))),IKFAST_ATAN2_MAGTHRESH);
if(!x273.valid){
continue;
}
CheckValue<IkReal> x274=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj4*r02))+((r01*sj4*sj5))+(((-1.0)*r00*sj4*x272)))),-1);
if(!x274.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x273.value)+(((1.5707963267949)*(x274.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x275=IKcos(j3);
IkReal x276=IKsin(j3);
IkReal x277=(r12*sj4);
IkReal x278=((1.0)*sj5);
IkReal x279=((1.0)*x275);
IkReal x280=(cj5*x275);
IkReal x281=(cj4*x276);
IkReal x282=(sj5*x275);
IkReal x283=((1.0)*x276);
evalcond[0]=((((-1.0)*r21*x278*x281))+((r21*x280))+(((-1.0)*r22*sj4*x283))+((cj5*r20*x281))+((r20*x282)));
evalcond[1]=((((-1.0)*r01*x278*x281))+((r01*x280))+((r00*x282))+((cj5*r00*x281))+(((-1.0)*r02*sj4*x283)));
evalcond[2]=((1.0)+((cj5*r10*x281))+(((-1.0)*x277*x283))+((r10*x282))+((r11*x280))+(((-1.0)*r11*x278*x281)));
evalcond[3]=((((-1.0)*x277*x279))+(((-1.0)*r10*x276*x278))+((cj4*r10*x280))+(((-1.0)*cj4*r11*x275*x278))+(((-1.0)*cj5*r11*x283)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x284=((12.0)*pz);
IkReal x285=((3.48732)*pz);
IkReal x286=(r21*sj5);
IkReal x287=((1.0510820652)*sj4);
IkReal x288=(cj5*r00);
IkReal x289=(cj5*r20);
IkReal x290=(cj4*r22);
IkReal x291=((3.48732)*sj4);
IkReal x292=((0.3503606884)*sj4);
IkReal x293=(cj4*r02);
IkReal x294=(r01*sj5);
IkReal x295=((1.16244)*sj4);
IkReal x296=((0.78)*x286);
IkReal x297=((0.04368)*x288);
IkReal x298=((0.2266758)*x286);
IkReal x299=(sj4*x294);
IkReal x300=((0.672)*x299);
IkReal x301=(x286*x291);
IkReal x302=(x286*x287);
IkReal x303=(x302+x298+x297+x285);
IkReal x304=(x300+x301+x296+x284);
IkReal x305=((((0.672)*px))+(((1.0510820652)*x290))+(((0.04368)*x294))+(((0.2266758)*x289))+((x287*x289)));
IkReal x306=((((0.78)*x289))+((x289*x291))+(((3.48732)*x290))+(((0.672)*x293))+(((0.672)*sj4*x288)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((0.2759322)+x303+(((-1.0)*x305)))))))+(((2.72212543554007)*(IKabs(((-0.2006682)+x303+(((-1.0)*x305)))))))+(((2.72212543554007)*(IKabs(((0.82)+x304+(((-1.0)*x306)))))))+(((2.72212543554007)*(IKabs(((0.2508442)+(((-0.0755586)*x289))+(((-1.0)*x289*x292))+(((-0.224)*px))+((x286*x292))+(((0.01456)*x288))+(((-0.3503606884)*x290))+(((-0.01456)*x294))+(((1.16244)*pz))+(((0.0755586)*x286)))))))+(((2.72212543554007)*(IKabs(((-0.82)+x304+(((-1.0)*x306)))))))+(((2.72212543554007)*(IKabs(((0.82)+(((0.26)*x286))+(((-0.224)*sj4*x288))+(((-1.0)*x289*x295))+(((4.0)*pz))+(((0.224)*x299))+(((-0.26)*x289))+((x286*x295))+(((-1.16244)*x290))+(((-0.224)*x293))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x307=((12.0)*pz);
IkReal x308=((4.0)*pz);
IkReal x309=(cj5*sj4);
IkReal x310=(cj4*r22);
IkReal x311=(r21*sj5);
IkReal x312=(cj5*r20);
IkReal x313=(cj4*r02);
IkReal x314=((0.78)*x311);
IkReal x315=((0.26)*x311);
IkReal x316=(r01*sj4*sj5);
IkReal x317=((0.672)*x316);
IkReal x318=((3.48732)*sj4*x311);
IkReal x319=((1.16244)*sj4*x311);
IkReal x320=((0.224)*x316);
IkReal x321=(x307+x318+x314+x317);
IkReal x322=(x308+x320+x319+x315);
IkReal x323=((((0.672)*x313))+(((0.672)*r00*x309))+(((3.48732)*x310))+(((0.78)*x312))+(((3.48732)*r20*x309)));
IkReal x324=((((0.224)*r00*x309))+(((1.16244)*r20*x309))+(((0.26)*x312))+(((1.16244)*x310))+(((0.224)*x313)));
op[0]=((0.82)+(((-1.0)*x324))+x322);
op[1]=0;
op[2]=((0.82)+(((-1.0)*x323))+x321);
op[3]=0;
op[4]=((-0.82)+(((-1.0)*x323))+x321);
op[5]=0;
op[6]=((-0.82)+(((-1.0)*x324))+x322);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x325=((3.48732)*pz);
IkReal x326=((1.16244)*pz);
IkReal x327=((0.224)*px);
IkReal x328=(r21*sj5);
IkReal x329=((1.0510820652)*sj4);
IkReal x330=(cj5*r00);
IkReal x331=(cj5*r20);
IkReal x332=(cj4*r22);
IkReal x333=((0.3503606884)*sj4);
IkReal x334=(r01*sj5);
IkReal x335=((0.0755586)*x328);
IkReal x336=((0.01456)*x330);
IkReal x337=((0.04368)*x330);
IkReal x338=((0.2266758)*x328);
IkReal x339=((0.3503606884)*x332);
IkReal x340=((0.0755586)*x331);
IkReal x341=((0.01456)*x334);
IkReal x342=(x328*x329);
IkReal x343=(x328*x333);
IkReal x344=(x331*x333);
IkReal x345=(x336+x335+x326+x343);
IkReal x346=(x338+x337+x325+x342);
IkReal x347=((((0.2266758)*x331))+(((0.672)*px))+(((1.0510820652)*x332))+((x329*x331))+(((0.04368)*x334)));
IkReal x348=(x339+x327+x340+x341+x344);
j1evalpoly[0]=((-0.2257562)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.2508442)+x345+(((-1.0)*x348))))))+(((-0.18368)*(htj1*htj1*htj1)))+x345+(((-0.09184)*(htj1*htj1*htj1*htj1*htj1)))+(((-1.0)*x348))+(((htj1*htj1*htj1*htj1)*(((0.2759322)+x346+(((-1.0)*x347))))))+(((-0.09184)*htj1))+(((htj1*htj1)*(((-0.2006682)+x346+(((-1.0)*x347)))))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x349=((1.0)*r00);
IkReal x350=((1.0)*sj1);
IkReal x351=(cj5*sj4);
IkReal x352=(cj4*r22);
IkReal x353=(cj4*r02);
IkReal x354=((1.0)*cj1);
IkReal x355=(r01*sj4*sj5);
IkReal x356=(cj1*x351);
IkReal x357=(r21*sj4*sj5);
if( IKabs((((cj1*x355))+(((-1.0)*x349*x356))+(((-1.0)*r20*x350*x351))+((sj1*x357))+(((-1.0)*x353*x354))+(((-1.0)*x350*x352)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x352))+(((-1.0)*sj1*x349*x351))+((sj1*x355))+(((-1.0)*x354*x357))+(((-1.0)*x350*x353))+((r20*x356)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*x355))+(((-1.0)*x349*x356))+(((-1.0)*r20*x350*x351))+((sj1*x357))+(((-1.0)*x353*x354))+(((-1.0)*x350*x352))))+IKsqr((((cj1*x352))+(((-1.0)*sj1*x349*x351))+((sj1*x355))+(((-1.0)*x354*x357))+(((-1.0)*x350*x353))+((r20*x356))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj1*x355))+(((-1.0)*x349*x356))+(((-1.0)*r20*x350*x351))+((sj1*x357))+(((-1.0)*x353*x354))+(((-1.0)*x350*x352))), (((cj1*x352))+(((-1.0)*sj1*x349*x351))+((sj1*x355))+(((-1.0)*x354*x357))+(((-1.0)*x350*x353))+((r20*x356))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x358=IKcos(j2);
IkReal x359=IKsin(j2);
IkReal x360=((0.29061)*sj1);
IkReal x361=(cj5*r00);
IkReal x362=((1.0)*cj3);
IkReal x363=(r01*sj5);
IkReal x364=(cj3*cj4);
IkReal x365=(r21*sj5);
IkReal x366=((1.0)*cj5);
IkReal x367=((1.0)*cj4);
IkReal x368=(cj5*r20);
IkReal x369=(cj1*x358);
IkReal x370=(cj1*x359);
IkReal x371=(sj1*x359);
IkReal x372=(sj1*x358);
IkReal x373=((1.0)*sj3*sj5);
IkReal x374=((1.0)*x371);
evalcond[0]=(((sj4*x365))+(((-1.0)*x374))+(((-1.0)*r20*sj4*x366))+x369+(((-1.0)*r22*x367)));
evalcond[1]=((((-1.0)*x370))+(((-1.0)*x372))+((sj4*x363))+(((-1.0)*r02*x367))+(((-1.0)*sj4*x361)));
evalcond[2]=((((-1.0)*r20*x373))+(((-1.0)*r21*sj3*x366))+((x364*x368))+(((-1.0)*r22*sj4*x362))+x372+x370+(((-1.0)*cj4*x362*x365)));
evalcond[3]=(((x361*x364))+(((-1.0)*r00*x373))+(((-1.0)*r01*sj3*x366))+(((-1.0)*x374))+(((-1.0)*r02*sj4*x362))+x369+(((-1.0)*cj4*x362*x363)));
evalcond[4]=((((0.205)*cj1))+(((-0.056)*x370))+(((-0.056)*x372))+(((0.29061)*x369))+(((-0.065)*x365))+(((-1.0)*pz))+(((-1.0)*x359*x360))+(((0.065)*x368)));
evalcond[5]=((0.056)+(((0.056)*x371))+(((-0.29061)*x370))+(((-0.056)*x369))+(((-1.0)*x358*x360))+(((-0.065)*x363))+(((-0.205)*sj1))+(((-1.0)*px))+(((0.065)*x361)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x375 = IKatan2WithCheck(IkReal((((r00*sj5))+((cj5*r01)))),IkReal(((((-1.0)*cj4*cj5*r00))+((r02*sj4))+((cj4*r01*sj5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x375.valid){
continue;
}
CheckValue<IkReal> x376=IKPowWithIntegerCheck(IKsign((((cj4*r22))+((cj5*r20*sj4))+(((-1.0)*r21*sj4*sj5)))),-1);
if(!x376.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x375.value)+(((1.5707963267949)*(x376.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x377=IKcos(j3);
IkReal x378=IKsin(j3);
IkReal x379=(r12*sj4);
IkReal x380=((1.0)*sj5);
IkReal x381=((1.0)*x377);
IkReal x382=(cj5*x377);
IkReal x383=(cj4*x378);
IkReal x384=(sj5*x377);
IkReal x385=((1.0)*x378);
evalcond[0]=((((-1.0)*r22*sj4*x385))+((r21*x382))+((cj5*r20*x383))+((r20*x384))+(((-1.0)*r21*x380*x383)));
evalcond[1]=(((cj5*r00*x383))+(((-1.0)*r02*sj4*x385))+(((-1.0)*r01*x380*x383))+((r00*x384))+((r01*x382)));
evalcond[2]=((1.0)+(((-1.0)*r11*x380*x383))+((r11*x382))+(((-1.0)*x379*x385))+((r10*x384))+((cj5*r10*x383)));
evalcond[3]=((((-1.0)*cj4*r11*x377*x380))+(((-1.0)*r10*x378*x380))+((cj4*r10*x382))+(((-1.0)*cj5*r11*x385))+(((-1.0)*x379*x381)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x386=((12.0)*pz);
IkReal x387=((3.48732)*pz);
IkReal x388=(r21*sj5);
IkReal x389=((1.0510820652)*sj4);
IkReal x390=(cj5*r00);
IkReal x391=(cj5*r20);
IkReal x392=(cj4*r22);
IkReal x393=((3.48732)*sj4);
IkReal x394=((0.3503606884)*sj4);
IkReal x395=(cj4*r02);
IkReal x396=(r01*sj5);
IkReal x397=((1.16244)*sj4);
IkReal x398=((0.78)*x388);
IkReal x399=((0.04368)*x390);
IkReal x400=((0.2266758)*x388);
IkReal x401=(sj4*x396);
IkReal x402=((0.672)*x401);
IkReal x403=(x388*x393);
IkReal x404=(x388*x389);
IkReal x405=(x387+x399+x400+x404);
IkReal x406=(x386+x398+x403+x402);
IkReal x407=((((0.672)*px))+(((0.04368)*x396))+(((0.2266758)*x391))+(((1.0510820652)*x392))+((x389*x391)));
IkReal x408=((((0.672)*sj4*x390))+((x391*x393))+(((0.672)*x395))+(((0.78)*x391))+(((3.48732)*x392)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((-0.2006682)+x405+(((-1.0)*x407)))))))+(((2.72212543554007)*(IKabs(((0.82)+(((-1.16244)*x392))+(((-0.224)*sj4*x390))+(((4.0)*pz))+(((0.26)*x388))+(((-1.0)*x391*x397))+(((-0.26)*x391))+(((-0.224)*x395))+((x388*x397))+(((0.224)*x401)))))))+(((2.72212543554007)*(IKabs(((0.2508442)+(((0.0755586)*x388))+(((-0.3503606884)*x392))+(((-1.0)*x391*x394))+(((-0.224)*px))+(((-0.0755586)*x391))+(((0.01456)*x390))+(((-0.01456)*x396))+(((1.16244)*pz))+((x388*x394)))))))+(((2.72212543554007)*(IKabs(((0.2759322)+x405+(((-1.0)*x407)))))))+(((2.72212543554007)*(IKabs(((-0.82)+x406+(((-1.0)*x408)))))))+(((2.72212543554007)*(IKabs(((0.82)+x406+(((-1.0)*x408))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x409=((12.0)*pz);
IkReal x410=((4.0)*pz);
IkReal x411=(cj5*sj4);
IkReal x412=(cj4*r22);
IkReal x413=(r21*sj5);
IkReal x414=(cj5*r20);
IkReal x415=(cj4*r02);
IkReal x416=((0.78)*x413);
IkReal x417=((0.26)*x413);
IkReal x418=(r01*sj4*sj5);
IkReal x419=((0.672)*x418);
IkReal x420=((3.48732)*sj4*x413);
IkReal x421=((1.16244)*sj4*x413);
IkReal x422=((0.224)*x418);
IkReal x423=(x409+x416+x419+x420);
IkReal x424=(x410+x417+x422+x421);
IkReal x425=((((0.672)*r00*x411))+(((0.672)*x415))+(((3.48732)*r20*x411))+(((3.48732)*x412))+(((0.78)*x414)));
IkReal x426=((((0.224)*x415))+(((1.16244)*r20*x411))+(((1.16244)*x412))+(((0.26)*x414))+(((0.224)*r00*x411)));
op[0]=((0.82)+(((-1.0)*x426))+x424);
op[1]=0;
op[2]=((0.82)+(((-1.0)*x425))+x423);
op[3]=0;
op[4]=((-0.82)+(((-1.0)*x425))+x423);
op[5]=0;
op[6]=((-0.82)+(((-1.0)*x426))+x424);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x427=((3.48732)*pz);
IkReal x428=((1.16244)*pz);
IkReal x429=((0.224)*px);
IkReal x430=(r21*sj5);
IkReal x431=((1.0510820652)*sj4);
IkReal x432=(cj5*r00);
IkReal x433=(cj5*r20);
IkReal x434=(cj4*r22);
IkReal x435=((0.3503606884)*sj4);
IkReal x436=(r01*sj5);
IkReal x437=((0.0755586)*x430);
IkReal x438=((0.01456)*x432);
IkReal x439=((0.04368)*x432);
IkReal x440=((0.2266758)*x430);
IkReal x441=((0.3503606884)*x434);
IkReal x442=((0.0755586)*x433);
IkReal x443=((0.01456)*x436);
IkReal x444=(x430*x431);
IkReal x445=(x430*x435);
IkReal x446=(x433*x435);
IkReal x447=(x428+x438+x437+x445);
IkReal x448=(x427+x439+x444+x440);
IkReal x449=((((0.672)*px))+(((0.04368)*x436))+(((1.0510820652)*x434))+(((0.2266758)*x433))+((x431*x433)));
IkReal x450=(x429+x446+x441+x443+x442);
j1evalpoly[0]=((-0.2257562)+(((htj1*htj1*htj1*htj1)*(((0.2759322)+(((-1.0)*x449))+x448))))+(((-0.18368)*(htj1*htj1*htj1)))+(((-1.0)*x450))+x447+(((-0.09184)*(htj1*htj1*htj1*htj1*htj1)))+(((-0.09184)*htj1))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.2508442)+(((-1.0)*x450))+x447))))+(((htj1*htj1)*(((-0.2006682)+(((-1.0)*x449))+x448)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x451=((1.0)*r00);
IkReal x452=((1.0)*sj1);
IkReal x453=(cj5*sj4);
IkReal x454=(cj4*r22);
IkReal x455=(cj4*r02);
IkReal x456=((1.0)*cj1);
IkReal x457=(r01*sj4*sj5);
IkReal x458=(cj1*x453);
IkReal x459=(r21*sj4*sj5);
if( IKabs((((cj1*x457))+((sj1*x459))+(((-1.0)*x455*x456))+(((-1.0)*x452*x454))+(((-1.0)*x451*x458))+(((-1.0)*r20*x452*x453)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x451*x453))+((cj1*x454))+((r20*x458))+(((-1.0)*x456*x459))+((sj1*x457))+(((-1.0)*x452*x455)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*x457))+((sj1*x459))+(((-1.0)*x455*x456))+(((-1.0)*x452*x454))+(((-1.0)*x451*x458))+(((-1.0)*r20*x452*x453))))+IKsqr(((((-1.0)*sj1*x451*x453))+((cj1*x454))+((r20*x458))+(((-1.0)*x456*x459))+((sj1*x457))+(((-1.0)*x452*x455))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj1*x457))+((sj1*x459))+(((-1.0)*x455*x456))+(((-1.0)*x452*x454))+(((-1.0)*x451*x458))+(((-1.0)*r20*x452*x453))), ((((-1.0)*sj1*x451*x453))+((cj1*x454))+((r20*x458))+(((-1.0)*x456*x459))+((sj1*x457))+(((-1.0)*x452*x455))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x460=IKcos(j2);
IkReal x461=IKsin(j2);
IkReal x462=((0.29061)*sj1);
IkReal x463=(cj5*r00);
IkReal x464=((1.0)*cj3);
IkReal x465=(r01*sj5);
IkReal x466=(cj3*cj4);
IkReal x467=(r21*sj5);
IkReal x468=((1.0)*cj5);
IkReal x469=((1.0)*cj4);
IkReal x470=(cj5*r20);
IkReal x471=(cj1*x460);
IkReal x472=(cj1*x461);
IkReal x473=(sj1*x461);
IkReal x474=(sj1*x460);
IkReal x475=((1.0)*sj3*sj5);
IkReal x476=((1.0)*x473);
evalcond[0]=((((-1.0)*x476))+((sj4*x467))+x471+(((-1.0)*r22*x469))+(((-1.0)*r20*sj4*x468)));
evalcond[1]=((((-1.0)*sj4*x463))+(((-1.0)*x472))+(((-1.0)*x474))+((sj4*x465))+(((-1.0)*r02*x469)));
evalcond[2]=(((x466*x470))+(((-1.0)*cj4*x464*x467))+x474+x472+(((-1.0)*r21*sj3*x468))+(((-1.0)*r22*sj4*x464))+(((-1.0)*r20*x475)));
evalcond[3]=((((-1.0)*r02*sj4*x464))+((x463*x466))+(((-1.0)*r00*x475))+(((-1.0)*x476))+(((-1.0)*cj4*x464*x465))+x471+(((-1.0)*r01*sj3*x468)));
evalcond[4]=((((0.205)*cj1))+(((-0.056)*x472))+(((-0.056)*x474))+(((0.065)*x470))+(((-1.0)*pz))+(((0.29061)*x471))+(((-0.065)*x467))+(((-1.0)*x461*x462)));
evalcond[5]=((0.056)+(((0.056)*x473))+(((-1.0)*x460*x462))+(((-0.056)*x471))+(((0.065)*x463))+(((-0.205)*sj1))+(((-1.0)*px))+(((-0.065)*x465))+(((-0.29061)*x472)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x477=(((cj5*r00*sj4))+(((-1.0)*r01*sj4*sj5))+((cj4*r02)));
j3eval[0]=x477;
j3eval[1]=((IKabs((((cj5*r21))+((r20*sj5)))))+(IKabs((((cj4*r21*sj5))+((r22*sj4))+(((-1.0)*cj4*cj5*r20))))));
j3eval[2]=IKsign(x477);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x478=((1.0)*cj5);
IkReal x479=(((r21*sj4*sj5))+(((-1.0)*r20*sj4*x478))+(((-1.0)*cj4*r22)));
j3eval[0]=x479;
j3eval[1]=((IKabs((((r00*sj5))+((cj5*r01)))))+(IKabs(((((-1.0)*cj4*r00*x478))+((r02*sj4))+((cj4*r01*sj5))))));
j3eval[2]=IKsign(x479);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x480=cj4*cj4;
IkReal x481=r10*r10;
IkReal x482=cj5*cj5;
IkReal x483=r11*r11;
IkReal x484=r12*r12;
IkReal x485=(cj5*r10);
IkReal x486=(r11*sj5);
IkReal x487=(r12*sj4);
IkReal x488=((2.0)*cj4);
IkReal x489=((1.0)*x480);
IkReal x490=(x482*x483);
IkReal x491=(x481*x482);
IkReal x492=((((-1.0)*x484*x489))+(((2.0)*x485*x486))+(((-1.0)*x489*x490))+(((-1.0)*x491))+((x480*x491))+((x486*x487*x488))+x481+x484+x490+((x480*x483))+(((-2.0)*x480*x485*x486))+(((-1.0)*x485*x487*x488)));
j3eval[0]=x492;
j3eval[1]=((IKabs(((((-1.0)*cj4*x486))+(((-1.0)*x487))+((cj4*x485)))))+(IKabs((((cj5*r11))+((r10*sj5))))));
j3eval[2]=IKsign(x492);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x493=cj4*cj4;
IkReal x494=r10*r10;
IkReal x495=cj5*cj5;
IkReal x496=r11*r11;
IkReal x497=r12*r12;
IkReal x498=(cj5*r10);
IkReal x499=(r11*sj5);
IkReal x500=(r12*sj4);
IkReal x501=((2.0)*cj4);
IkReal x502=((1.0)*x493);
IkReal x503=(x495*x496);
IkReal x504=(x494*x495);
CheckValue<IkReal> x505=IKPowWithIntegerCheck(IKsign(((((-1.0)*x497*x502))+((x493*x496))+(((-1.0)*x502*x503))+((x493*x504))+((x499*x500*x501))+x497+x494+x503+(((-2.0)*x493*x498*x499))+(((-1.0)*x498*x500*x501))+(((-1.0)*x504))+(((2.0)*x498*x499)))),-1);
if(!x505.valid){
continue;
}
CheckValue<IkReal> x506 = IKatan2WithCheck(IkReal(((((-1.0)*cj4*x499))+((cj4*x498))+(((-1.0)*x500)))),IkReal((((cj5*r11))+((r10*sj5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x506.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x505.value)))+(x506.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x507=IKcos(j3);
IkReal x508=IKsin(j3);
IkReal x509=(r12*sj4);
IkReal x510=((1.0)*sj5);
IkReal x511=((1.0)*x507);
IkReal x512=(cj5*x507);
IkReal x513=(cj4*x508);
IkReal x514=(sj5*x507);
IkReal x515=((1.0)*x508);
evalcond[0]=((((-1.0)*r22*sj4*x515))+((r20*x514))+((cj5*r20*x513))+((r21*x512))+(((-1.0)*r21*x510*x513)));
evalcond[1]=(((r01*x512))+(((-1.0)*r01*x510*x513))+((cj5*r00*x513))+(((-1.0)*r02*sj4*x515))+((r00*x514)));
evalcond[2]=((-1.0)+((r11*x512))+((cj5*r10*x513))+((r10*x514))+(((-1.0)*r11*x510*x513))+(((-1.0)*x509*x515)));
evalcond[3]=((((-1.0)*cj5*r11*x515))+(((-1.0)*r10*x508*x510))+(((-1.0)*x509*x511))+(((-1.0)*cj4*r11*x507*x510))+((cj4*r10*x512)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x516=(r21*sj5);
IkReal x517=(cj5*r00);
IkReal x518=(cj5*r20);
IkReal x519=(cj4*r22);
IkReal x520=(cj4*r02);
IkReal x521=(r01*sj5);
IkReal x522=((0.2266758)*x518);
IkReal x523=((0.04368)*x517);
IkReal x524=((1.0510820652)*x519);
IkReal x525=((3.48732)*x519);
IkReal x526=((0.78)*x518);
IkReal x527=(sj4*x516);
IkReal x528=(sj4*x521);
IkReal x529=((1.0510820652)*sj4*x518);
IkReal x530=((3.48732)*sj4*x518);
IkReal x531=((0.672)*x528);
IkReal x532=(x522+x523+x524+x529);
IkReal x533=((((0.672)*px))+(((0.2266758)*x516))+(((0.04368)*x521))+(((1.0510820652)*x527))+(((3.48732)*pz)));
IkReal x534=(x531+x530+x526+x525);
IkReal x535=((((12.0)*pz))+(((0.672)*x520))+(((0.78)*x516))+(((3.48732)*x527))+(((0.672)*sj4*x517)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((-0.82)+(((-1.0)*x535))+x534)))))+(((2.72212543554007)*(IKabs(((0.82)+(((-1.0)*x535))+x534)))))+(((2.72212543554007)*(IKabs(((0.2006682)+(((-1.0)*x533))+x532)))))+(((2.72212543554007)*(IKabs(((-0.2759322)+(((-1.0)*x533))+x532)))))+(((2.72212543554007)*(IKabs(((-0.82)+(((-0.26)*x516))+(((1.16244)*x519))+(((1.16244)*sj4*x518))+(((-0.224)*x520))+(((-4.0)*pz))+(((-1.16244)*x527))+(((0.224)*x528))+(((-0.224)*sj4*x517))+(((0.26)*x518)))))))+(((2.72212543554007)*(IKabs(((-0.2508442)+(((-1.16244)*pz))+(((-0.3503606884)*x527))+(((-0.224)*px))+(((-0.0755586)*x516))+(((0.3503606884)*sj4*x518))+(((0.0755586)*x518))+(((0.3503606884)*x519))+(((-0.01456)*x521))+(((0.01456)*x517))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x536=(cj5*sj4);
IkReal x537=(cj4*r22);
IkReal x538=(sj4*sj5);
IkReal x539=(r21*sj5);
IkReal x540=(cj5*r20);
IkReal x541=(cj4*r02);
IkReal x542=((3.48732)*x537);
IkReal x543=((0.78)*x540);
IkReal x544=((1.16244)*x537);
IkReal x545=((0.26)*x540);
IkReal x546=((3.48732)*r20*x536);
IkReal x547=((0.672)*r01*x538);
IkReal x548=((1.16244)*r20*x536);
IkReal x549=((0.224)*r01*x538);
IkReal x550=(x546+x547+x542+x543);
IkReal x551=(x544+x545+x548+x549);
IkReal x552=((((12.0)*pz))+(((3.48732)*r21*x538))+(((0.672)*x541))+(((0.78)*x539))+(((0.672)*r00*x536)));
IkReal x553=((((1.16244)*r21*x538))+(((4.0)*pz))+(((0.224)*r00*x536))+(((0.224)*x541))+(((0.26)*x539)));
op[0]=((-0.82)+(((-1.0)*x553))+x551);
op[1]=0;
op[2]=((-0.82)+(((-1.0)*x552))+x550);
op[3]=0;
op[4]=((0.82)+(((-1.0)*x552))+x550);
op[5]=0;
op[6]=((0.82)+(((-1.0)*x553))+x551);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x554=(r21*sj5);
IkReal x555=((1.0510820652)*sj4);
IkReal x556=(cj5*r00);
IkReal x557=(cj5*r20);
IkReal x558=(cj4*r22);
IkReal x559=((0.3503606884)*sj4);
IkReal x560=(r01*sj5);
IkReal x561=((0.3503606884)*x558);
IkReal x562=((0.2266758)*x557);
IkReal x563=((0.04368)*x556);
IkReal x564=((1.0510820652)*x558);
IkReal x565=((0.01456)*x556);
IkReal x566=((0.0755586)*x557);
IkReal x567=(x555*x557);
IkReal x568=(x557*x559);
IkReal x569=(x568+x566+x565+x561);
IkReal x570=(x567+x564+x562+x563);
IkReal x571=((((0.672)*px))+((x554*x555))+(((0.2266758)*x554))+(((0.04368)*x560))+(((3.48732)*pz)));
IkReal x572=((((0.224)*px))+(((0.0755586)*x554))+(((0.01456)*x560))+((x554*x559))+(((1.16244)*pz)));
j1evalpoly[0]=((0.2257562)+(((0.09184)*(htj1*htj1*htj1*htj1*htj1)))+(((-1.0)*x572))+x569+(((0.09184)*htj1))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.2508442)+(((-1.0)*x572))+x569))))+(((0.18368)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((-0.2759322)+(((-1.0)*x571))+x570))))+(((htj1*htj1)*(((0.2006682)+(((-1.0)*x571))+x570)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x573=(cj4*sj1);
IkReal x574=(cj1*sj4);
IkReal x575=(cj5*r20);
IkReal x576=(sj1*sj4);
IkReal x577=(r21*sj5);
IkReal x578=(cj5*r00);
IkReal x579=(cj1*cj4);
IkReal x580=((1.0)*r01*sj5);
if( IKabs((((x576*x577))+((x574*x578))+((r02*x579))+(((-1.0)*r22*x573))+(((-1.0)*x575*x576))+(((-1.0)*x574*x580)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x576*x578))+((x574*x575))+((r02*x573))+(((-1.0)*x576*x580))+((r22*x579))+(((-1.0)*x574*x577)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x576*x577))+((x574*x578))+((r02*x579))+(((-1.0)*r22*x573))+(((-1.0)*x575*x576))+(((-1.0)*x574*x580))))+IKsqr((((x576*x578))+((x574*x575))+((r02*x573))+(((-1.0)*x576*x580))+((r22*x579))+(((-1.0)*x574*x577))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x576*x577))+((x574*x578))+((r02*x579))+(((-1.0)*r22*x573))+(((-1.0)*x575*x576))+(((-1.0)*x574*x580))), (((x576*x578))+((x574*x575))+((r02*x573))+(((-1.0)*x576*x580))+((r22*x579))+(((-1.0)*x574*x577))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x581=IKcos(j2);
IkReal x582=IKsin(j2);
IkReal x583=((0.29061)*sj1);
IkReal x584=(cj5*r00);
IkReal x585=((1.0)*cj3);
IkReal x586=(r01*sj5);
IkReal x587=(cj3*cj4);
IkReal x588=(r21*sj5);
IkReal x589=((1.0)*cj5);
IkReal x590=((1.0)*cj4);
IkReal x591=(cj5*r20);
IkReal x592=(sj1*x581);
IkReal x593=(cj1*x582);
IkReal x594=(cj1*x581);
IkReal x595=(sj1*x582);
IkReal x596=((1.0)*sj3*sj5);
IkReal x597=(x593+x592);
evalcond[0]=((((-1.0)*sj4*x584))+x597+(((-1.0)*r02*x590))+((sj4*x586)));
evalcond[1]=((((-1.0)*r20*sj4*x589))+(((-1.0)*x595))+x594+(((-1.0)*r22*x590))+((sj4*x588)));
evalcond[2]=((((-1.0)*r20*x596))+(((-1.0)*r22*sj4*x585))+(((-1.0)*r21*sj3*x589))+x597+(((-1.0)*cj4*x585*x588))+((x587*x591)));
evalcond[3]=(((x584*x587))+(((-1.0)*r00*x596))+(((-1.0)*r02*sj4*x585))+(((-1.0)*x594))+x595+(((-1.0)*r01*sj3*x589))+(((-1.0)*cj4*x585*x586)));
evalcond[4]=((((0.205)*cj1))+(((-1.0)*x582*x583))+(((-1.0)*pz))+(((0.29061)*x594))+(((0.065)*x591))+(((-0.056)*x593))+(((-0.056)*x592))+(((-0.065)*x588)));
evalcond[5]=((-0.056)+(((0.056)*x594))+((x581*x583))+(((0.065)*x584))+(((0.205)*sj1))+(((-1.0)*px))+(((0.29061)*x593))+(((-0.056)*x595))+(((-0.065)*x586)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x598=((1.0)*cj5);
CheckValue<IkReal> x599 = IKatan2WithCheck(IkReal((((r00*sj5))+((cj5*r01)))),IkReal(((((-1.0)*cj4*r00*x598))+((r02*sj4))+((cj4*r01*sj5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x599.valid){
continue;
}
CheckValue<IkReal> x600=IKPowWithIntegerCheck(IKsign((((r21*sj4*sj5))+(((-1.0)*r20*sj4*x598))+(((-1.0)*cj4*r22)))),-1);
if(!x600.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x599.value)+(((1.5707963267949)*(x600.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x601=IKcos(j3);
IkReal x602=IKsin(j3);
IkReal x603=(r12*sj4);
IkReal x604=((1.0)*sj5);
IkReal x605=((1.0)*x601);
IkReal x606=(cj5*x601);
IkReal x607=(cj4*x602);
IkReal x608=(sj5*x601);
IkReal x609=((1.0)*x602);
evalcond[0]=((((-1.0)*r21*x604*x607))+((r20*x608))+((cj5*r20*x607))+((r21*x606))+(((-1.0)*r22*sj4*x609)));
evalcond[1]=(((r00*x608))+(((-1.0)*r02*sj4*x609))+(((-1.0)*r01*x604*x607))+((cj5*r00*x607))+((r01*x606)));
evalcond[2]=((-1.0)+(((-1.0)*r11*x604*x607))+(((-1.0)*x603*x609))+((cj5*r10*x607))+((r11*x606))+((r10*x608)));
evalcond[3]=((((-1.0)*x603*x605))+(((-1.0)*cj5*r11*x609))+((cj4*r10*x606))+(((-1.0)*cj4*r11*x601*x604))+(((-1.0)*r10*x602*x604)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x610=(r21*sj5);
IkReal x611=(cj5*r00);
IkReal x612=(cj5*r20);
IkReal x613=(cj4*r22);
IkReal x614=(cj4*r02);
IkReal x615=(r01*sj5);
IkReal x616=((0.2266758)*x612);
IkReal x617=((0.04368)*x611);
IkReal x618=((1.0510820652)*x613);
IkReal x619=((3.48732)*x613);
IkReal x620=((0.78)*x612);
IkReal x621=(sj4*x610);
IkReal x622=(sj4*x615);
IkReal x623=((1.0510820652)*sj4*x612);
IkReal x624=((3.48732)*sj4*x612);
IkReal x625=((0.672)*x622);
IkReal x626=(x618+x616+x617+x623);
IkReal x627=((((0.672)*px))+(((1.0510820652)*x621))+(((0.2266758)*x610))+(((0.04368)*x615))+(((3.48732)*pz)));
IkReal x628=(x619+x625+x624+x620);
IkReal x629=((((3.48732)*x621))+(((12.0)*pz))+(((0.78)*x610))+(((0.672)*sj4*x611))+(((0.672)*x614)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((0.82)+(((-1.0)*x629))+x628)))))+(((2.72212543554007)*(IKabs(((-0.2759322)+(((-1.0)*x627))+x626)))))+(((2.72212543554007)*(IKabs(((0.2006682)+(((-1.0)*x627))+x626)))))+(((2.72212543554007)*(IKabs(((-0.2508442)+(((0.0755586)*x612))+(((-1.16244)*pz))+(((0.3503606884)*sj4*x612))+(((0.01456)*x611))+(((0.3503606884)*x613))+(((-0.224)*px))+(((-0.3503606884)*x621))+(((-0.01456)*x615))+(((-0.0755586)*x610)))))))+(((2.72212543554007)*(IKabs(((-0.82)+(((1.16244)*x613))+(((1.16244)*sj4*x612))+(((-0.224)*x614))+(((-0.26)*x610))+(((0.26)*x612))+(((0.224)*x622))+(((-1.16244)*x621))+(((-0.224)*sj4*x611))+(((-4.0)*pz)))))))+(((2.72212543554007)*(IKabs(((-0.82)+(((-1.0)*x629))+x628))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x630=(cj5*sj4);
IkReal x631=(cj4*r22);
IkReal x632=(sj4*sj5);
IkReal x633=(r21*sj5);
IkReal x634=(cj5*r20);
IkReal x635=(cj4*r02);
IkReal x636=((3.48732)*x631);
IkReal x637=((0.78)*x634);
IkReal x638=((1.16244)*x631);
IkReal x639=((0.26)*x634);
IkReal x640=((3.48732)*r20*x630);
IkReal x641=((0.672)*r01*x632);
IkReal x642=((1.16244)*r20*x630);
IkReal x643=((0.224)*r01*x632);
IkReal x644=(x641+x640+x636+x637);
IkReal x645=(x643+x642+x638+x639);
IkReal x646=((((12.0)*pz))+(((0.672)*x635))+(((0.78)*x633))+(((3.48732)*r21*x632))+(((0.672)*r00*x630)));
IkReal x647=((((1.16244)*r21*x632))+(((4.0)*pz))+(((0.224)*x635))+(((0.26)*x633))+(((0.224)*r00*x630)));
op[0]=((-0.82)+(((-1.0)*x647))+x645);
op[1]=0;
op[2]=((-0.82)+(((-1.0)*x646))+x644);
op[3]=0;
op[4]=((0.82)+(((-1.0)*x646))+x644);
op[5]=0;
op[6]=((0.82)+(((-1.0)*x647))+x645);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x648=(r21*sj5);
IkReal x649=((1.0510820652)*sj4);
IkReal x650=(cj5*r00);
IkReal x651=(cj5*r20);
IkReal x652=(cj4*r22);
IkReal x653=((0.3503606884)*sj4);
IkReal x654=(r01*sj5);
IkReal x655=((0.3503606884)*x652);
IkReal x656=((0.2266758)*x651);
IkReal x657=((0.04368)*x650);
IkReal x658=((1.0510820652)*x652);
IkReal x659=((0.01456)*x650);
IkReal x660=((0.0755586)*x651);
IkReal x661=(x649*x651);
IkReal x662=(x651*x653);
IkReal x663=(x655+x659+x660+x662);
IkReal x664=(x656+x657+x658+x661);
IkReal x665=((((0.672)*px))+((x648*x649))+(((3.48732)*pz))+(((0.04368)*x654))+(((0.2266758)*x648)));
IkReal x666=((((0.224)*px))+(((0.01456)*x654))+((x648*x653))+(((0.0755586)*x648))+(((1.16244)*pz)));
j1evalpoly[0]=((0.2257562)+(((htj1*htj1*htj1*htj1)*(((-0.2759322)+(((-1.0)*x665))+x664))))+(((htj1*htj1)*(((0.2006682)+(((-1.0)*x665))+x664))))+(((0.09184)*(htj1*htj1*htj1*htj1*htj1)))+(((-1.0)*x666))+x663+(((0.09184)*htj1))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.2508442)+(((-1.0)*x666))+x663))))+(((0.18368)*(htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x667=(cj4*sj1);
IkReal x668=(cj1*sj4);
IkReal x669=(cj5*r20);
IkReal x670=(sj1*sj4);
IkReal x671=(r21*sj5);
IkReal x672=(cj5*r00);
IkReal x673=(cj1*cj4);
IkReal x674=((1.0)*r01*sj5);
if( IKabs((((r02*x673))+((x670*x671))+(((-1.0)*x668*x674))+(((-1.0)*r22*x667))+((x668*x672))+(((-1.0)*x669*x670)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x668*x669))+((r22*x673))+((x670*x672))+(((-1.0)*x670*x674))+((r02*x667))+(((-1.0)*x668*x671)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r02*x673))+((x670*x671))+(((-1.0)*x668*x674))+(((-1.0)*r22*x667))+((x668*x672))+(((-1.0)*x669*x670))))+IKsqr((((x668*x669))+((r22*x673))+((x670*x672))+(((-1.0)*x670*x674))+((r02*x667))+(((-1.0)*x668*x671))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((r02*x673))+((x670*x671))+(((-1.0)*x668*x674))+(((-1.0)*r22*x667))+((x668*x672))+(((-1.0)*x669*x670))), (((x668*x669))+((r22*x673))+((x670*x672))+(((-1.0)*x670*x674))+((r02*x667))+(((-1.0)*x668*x671))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x675=IKcos(j2);
IkReal x676=IKsin(j2);
IkReal x677=((0.29061)*sj1);
IkReal x678=(cj5*r00);
IkReal x679=((1.0)*cj3);
IkReal x680=(r01*sj5);
IkReal x681=(cj3*cj4);
IkReal x682=(r21*sj5);
IkReal x683=((1.0)*cj5);
IkReal x684=((1.0)*cj4);
IkReal x685=(cj5*r20);
IkReal x686=(sj1*x675);
IkReal x687=(cj1*x676);
IkReal x688=(cj1*x675);
IkReal x689=(sj1*x676);
IkReal x690=((1.0)*sj3*sj5);
IkReal x691=(x687+x686);
evalcond[0]=((((-1.0)*r02*x684))+(((-1.0)*sj4*x678))+x691+((sj4*x680)));
evalcond[1]=((((-1.0)*r20*sj4*x683))+x688+(((-1.0)*r22*x684))+(((-1.0)*x689))+((sj4*x682)));
evalcond[2]=((((-1.0)*r22*sj4*x679))+(((-1.0)*cj4*x679*x682))+((x681*x685))+(((-1.0)*r21*sj3*x683))+x691+(((-1.0)*r20*x690)));
evalcond[3]=((((-1.0)*r00*x690))+((x678*x681))+(((-1.0)*cj4*x679*x680))+(((-1.0)*r01*sj3*x683))+x689+(((-1.0)*r02*sj4*x679))+(((-1.0)*x688)));
evalcond[4]=((((0.205)*cj1))+(((-0.056)*x687))+(((-0.056)*x686))+(((-0.065)*x682))+(((-1.0)*pz))+(((-1.0)*x676*x677))+(((0.29061)*x688))+(((0.065)*x685)));
evalcond[5]=((-0.056)+(((0.056)*x688))+(((-0.056)*x689))+(((-0.065)*x680))+(((0.205)*sj1))+(((-1.0)*px))+(((0.065)*x678))+(((0.29061)*x687))+((x675*x677)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x692=IKPowWithIntegerCheck(IKsign((((cj5*r00*sj4))+(((-1.0)*r01*sj4*sj5))+((cj4*r02)))),-1);
if(!x692.valid){
continue;
}
CheckValue<IkReal> x693 = IKatan2WithCheck(IkReal((((cj5*r21))+((r20*sj5)))),IkReal((((cj4*r21*sj5))+((r22*sj4))+(((-1.0)*cj4*cj5*r20)))),IKFAST_ATAN2_MAGTHRESH);
if(!x693.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x692.value)))+(x693.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x694=IKcos(j3);
IkReal x695=IKsin(j3);
IkReal x696=(r12*sj4);
IkReal x697=((1.0)*sj5);
IkReal x698=((1.0)*x694);
IkReal x699=(cj5*x694);
IkReal x700=(cj4*x695);
IkReal x701=(sj5*x694);
IkReal x702=((1.0)*x695);
evalcond[0]=((((-1.0)*r21*x697*x700))+((cj5*r20*x700))+((r20*x701))+(((-1.0)*r22*sj4*x702))+((r21*x699)));
evalcond[1]=(((r00*x701))+(((-1.0)*r01*x697*x700))+(((-1.0)*r02*sj4*x702))+((cj5*r00*x700))+((r01*x699)));
evalcond[2]=((-1.0)+((cj5*r10*x700))+(((-1.0)*r11*x697*x700))+(((-1.0)*x696*x702))+((r11*x699))+((r10*x701)));
evalcond[3]=((((-1.0)*cj4*r11*x694*x697))+(((-1.0)*x696*x698))+(((-1.0)*cj5*r11*x702))+((cj4*r10*x699))+(((-1.0)*r10*x695*x697)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x703=(r21*sj5);
IkReal x704=(cj5*r00);
IkReal x705=(cj5*r20);
IkReal x706=(cj4*r22);
IkReal x707=(cj4*r02);
IkReal x708=(r01*sj5);
IkReal x709=((0.2266758)*x705);
IkReal x710=((0.04368)*x704);
IkReal x711=((1.0510820652)*x706);
IkReal x712=((3.48732)*x706);
IkReal x713=((0.78)*x705);
IkReal x714=(sj4*x703);
IkReal x715=(sj4*x708);
IkReal x716=((1.0510820652)*sj4*x705);
IkReal x717=((3.48732)*sj4*x705);
IkReal x718=((0.672)*x715);
IkReal x719=(x711+x710+x716+x709);
IkReal x720=((((0.2266758)*x703))+(((0.672)*px))+(((0.04368)*x708))+(((1.0510820652)*x714))+(((3.48732)*pz)));
IkReal x721=(x718+x713+x712+x717);
IkReal x722=((((3.48732)*x714))+(((12.0)*pz))+(((0.672)*x707))+(((0.672)*sj4*x704))+(((0.78)*x703)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((0.2006682)+(((-1.0)*x720))+x719)))))+(((2.72212543554007)*(IKabs(((-0.82)+(((-1.0)*x722))+x721)))))+(((2.72212543554007)*(IKabs(((0.82)+(((-1.0)*x722))+x721)))))+(((2.72212543554007)*(IKabs(((-0.2759322)+(((-1.0)*x720))+x719)))))+(((2.72212543554007)*(IKabs(((-0.82)+(((-0.26)*x703))+(((0.26)*x705))+(((-1.16244)*x714))+(((-0.224)*x707))+(((-0.224)*sj4*x704))+(((0.224)*x715))+(((1.16244)*sj4*x705))+(((1.16244)*x706))+(((-4.0)*pz)))))))+(((2.72212543554007)*(IKabs(((-0.2508442)+(((0.3503606884)*x706))+(((0.3503606884)*sj4*x705))+(((-1.16244)*pz))+(((-0.01456)*x708))+(((-0.224)*px))+(((-0.3503606884)*x714))+(((0.0755586)*x705))+(((-0.0755586)*x703))+(((0.01456)*x704))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x723=(cj5*sj4);
IkReal x724=(cj4*r22);
IkReal x725=(sj4*sj5);
IkReal x726=(r21*sj5);
IkReal x727=(cj5*r20);
IkReal x728=(cj4*r02);
IkReal x729=((3.48732)*x724);
IkReal x730=((0.78)*x727);
IkReal x731=((1.16244)*x724);
IkReal x732=((0.26)*x727);
IkReal x733=((3.48732)*r20*x723);
IkReal x734=((0.672)*r01*x725);
IkReal x735=((1.16244)*r20*x723);
IkReal x736=((0.224)*r01*x725);
IkReal x737=(x734+x733+x730+x729);
IkReal x738=(x736+x735+x732+x731);
IkReal x739=((((0.672)*r00*x723))+(((12.0)*pz))+(((0.672)*x728))+(((0.78)*x726))+(((3.48732)*r21*x725)));
IkReal x740=((((0.26)*x726))+(((4.0)*pz))+(((1.16244)*r21*x725))+(((0.224)*x728))+(((0.224)*r00*x723)));
op[0]=((-0.82)+x738+(((-1.0)*x740)));
op[1]=0;
op[2]=((-0.82)+(((-1.0)*x739))+x737);
op[3]=0;
op[4]=((0.82)+(((-1.0)*x739))+x737);
op[5]=0;
op[6]=((0.82)+x738+(((-1.0)*x740)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x741=(r21*sj5);
IkReal x742=((1.0510820652)*sj4);
IkReal x743=(cj5*r00);
IkReal x744=(cj5*r20);
IkReal x745=(cj4*r22);
IkReal x746=((0.3503606884)*sj4);
IkReal x747=(r01*sj5);
IkReal x748=((0.3503606884)*x745);
IkReal x749=((0.2266758)*x744);
IkReal x750=((0.04368)*x743);
IkReal x751=((1.0510820652)*x745);
IkReal x752=((0.01456)*x743);
IkReal x753=((0.0755586)*x744);
IkReal x754=(x742*x744);
IkReal x755=(x744*x746);
IkReal x756=(x755+x753+x752+x748);
IkReal x757=(x754+x751+x750+x749);
IkReal x758=((((0.04368)*x747))+(((0.672)*px))+((x741*x742))+(((0.2266758)*x741))+(((3.48732)*pz)));
IkReal x759=((((0.224)*px))+(((0.0755586)*x741))+((x741*x746))+(((0.01456)*x747))+(((1.16244)*pz)));
j1evalpoly[0]=((0.2257562)+(((htj1*htj1)*(((0.2006682)+x757+(((-1.0)*x758))))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.2508442)+x756+(((-1.0)*x759))))))+(((0.09184)*(htj1*htj1*htj1*htj1*htj1)))+x756+(((0.09184)*htj1))+(((htj1*htj1*htj1*htj1)*(((-0.2759322)+x757+(((-1.0)*x758))))))+(((-1.0)*x759))+(((0.18368)*(htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x760=(cj4*sj1);
IkReal x761=(cj1*sj4);
IkReal x762=(cj5*r20);
IkReal x763=(sj1*sj4);
IkReal x764=(r21*sj5);
IkReal x765=(cj5*r00);
IkReal x766=(cj1*cj4);
IkReal x767=((1.0)*r01*sj5);
if( IKabs(((((-1.0)*r22*x760))+((x761*x765))+((x763*x764))+((r02*x766))+(((-1.0)*x762*x763))+(((-1.0)*x761*x767)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x761*x764))+(((-1.0)*x763*x767))+((x761*x762))+((x763*x765))+((r02*x760))+((r22*x766)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r22*x760))+((x761*x765))+((x763*x764))+((r02*x766))+(((-1.0)*x762*x763))+(((-1.0)*x761*x767))))+IKsqr(((((-1.0)*x761*x764))+(((-1.0)*x763*x767))+((x761*x762))+((x763*x765))+((r02*x760))+((r22*x766))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*r22*x760))+((x761*x765))+((x763*x764))+((r02*x766))+(((-1.0)*x762*x763))+(((-1.0)*x761*x767))), ((((-1.0)*x761*x764))+(((-1.0)*x763*x767))+((x761*x762))+((x763*x765))+((r02*x760))+((r22*x766))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x768=IKcos(j2);
IkReal x769=IKsin(j2);
IkReal x770=((0.29061)*sj1);
IkReal x771=(cj5*r00);
IkReal x772=((1.0)*cj3);
IkReal x773=(r01*sj5);
IkReal x774=(cj3*cj4);
IkReal x775=(r21*sj5);
IkReal x776=((1.0)*cj5);
IkReal x777=((1.0)*cj4);
IkReal x778=(cj5*r20);
IkReal x779=(sj1*x768);
IkReal x780=(cj1*x769);
IkReal x781=(cj1*x768);
IkReal x782=(sj1*x769);
IkReal x783=((1.0)*sj3*sj5);
IkReal x784=(x779+x780);
evalcond[0]=(((sj4*x773))+(((-1.0)*sj4*x771))+(((-1.0)*r02*x777))+x784);
evalcond[1]=(((sj4*x775))+(((-1.0)*r22*x777))+x781+(((-1.0)*x782))+(((-1.0)*r20*sj4*x776)));
evalcond[2]=(((x774*x778))+(((-1.0)*r22*sj4*x772))+(((-1.0)*r20*x783))+(((-1.0)*cj4*x772*x775))+x784+(((-1.0)*r21*sj3*x776)));
evalcond[3]=((((-1.0)*r00*x783))+((x771*x774))+(((-1.0)*r01*sj3*x776))+(((-1.0)*cj4*x772*x773))+x782+(((-1.0)*x781))+(((-1.0)*r02*sj4*x772)));
evalcond[4]=((((-0.056)*x780))+(((0.205)*cj1))+(((-0.056)*x779))+(((-1.0)*pz))+(((-1.0)*x769*x770))+(((-0.065)*x775))+(((0.29061)*x781))+(((0.065)*x778)));
evalcond[5]=((-0.056)+(((-0.056)*x782))+(((0.205)*sj1))+(((-1.0)*px))+(((-0.065)*x773))+(((0.056)*x781))+(((0.29061)*x780))+(((0.065)*x771))+((x768*x770)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x785=(((cj4*r22))+((cj5*r20*sj4))+(((-1.0)*r21*sj4*sj5)));
j3eval[0]=x785;
j3eval[1]=((IKabs(((((-1.0)*cj4*cj5*r10))+((r12*sj4))+((cj4*r11*sj5)))))+(IKabs((((cj5*r11))+((r10*sj5))))));
j3eval[2]=IKsign(x785);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x786=((1.0)*cj5);
IkReal x787=(((r11*sj4*sj5))+(((-1.0)*r10*sj4*x786))+(((-1.0)*cj4*r12)));
j3eval[0]=x787;
j3eval[1]=IKsign(x787);
j3eval[2]=((IKabs((((cj4*r21*sj5))+((r22*sj4))+(((-1.0)*cj4*r20*x786)))))+(IKabs((((cj5*r21))+((r20*sj5))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x788=r00*r00;
IkReal x789=cj5*cj5;
IkReal x790=cj4*cj4;
IkReal x791=r01*r01;
IkReal x792=r02*r02;
IkReal x793=(r00*sj5);
IkReal x794=((2.0)*cj5);
IkReal x795=(r02*sj4);
IkReal x796=(cj4*r00);
IkReal x797=((1.0)*x790);
IkReal x798=(cj4*r01*sj5);
IkReal x799=(x788*x789);
IkReal x800=(x789*x791);
IkReal x801=((((-1.0)*r01*x790*x793*x794))+(((-1.0)*x792*x797))+((x790*x791))+((x790*x799))+(((-1.0)*x797*x800))+(((2.0)*x795*x798))+((r01*x793*x794))+x792+x788+(((-1.0)*x799))+x800+(((-1.0)*x794*x795*x796)));
j3eval[0]=x801;
j3eval[1]=IKsign(x801);
j3eval[2]=((IKabs((((cj5*x796))+(((-1.0)*x798))+(((-1.0)*x795)))))+(IKabs((x793+((cj5*r01))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x802=r00*r00;
IkReal x803=cj5*cj5;
IkReal x804=cj4*cj4;
IkReal x805=r01*r01;
IkReal x806=r02*r02;
IkReal x807=(r00*sj5);
IkReal x808=((2.0)*cj5);
IkReal x809=(r02*sj4);
IkReal x810=(cj4*r00);
IkReal x811=((1.0)*x804);
IkReal x812=(cj4*r01*sj5);
IkReal x813=(x802*x803);
IkReal x814=(x803*x805);
CheckValue<IkReal> x815 = IKatan2WithCheck(IkReal(((((-1.0)*x809))+(((-1.0)*x812))+((cj5*x810)))),IkReal((x807+((cj5*r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x815.valid){
continue;
}
CheckValue<IkReal> x816=IKPowWithIntegerCheck(IKsign(((((2.0)*x809*x812))+((r01*x807*x808))+((x804*x805))+(((-1.0)*x811*x814))+(((-1.0)*x813))+(((-1.0)*r01*x804*x807*x808))+((x804*x813))+x814+x806+x802+(((-1.0)*x808*x809*x810))+(((-1.0)*x806*x811)))),-1);
if(!x816.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x815.value)+(((1.5707963267949)*(x816.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x817=IKcos(j3);
IkReal x818=IKsin(j3);
IkReal x819=((1.0)*sj4);
IkReal x820=(cj4*r00);
IkReal x821=((1.0)*r01);
IkReal x822=(cj5*x817);
IkReal x823=(cj5*x818);
IkReal x824=(sj5*x817);
IkReal x825=((1.0)*sj5*x818);
evalcond[0]=(((r21*x822))+((r20*x824))+(((-1.0)*cj4*r21*x825))+(((-1.0)*r22*x818*x819))+((cj4*r20*x823)));
evalcond[1]=(((r10*x824))+(((-1.0)*r12*x818*x819))+(((-1.0)*cj4*r11*x825))+((cj4*r10*x823))+((r11*x822)));
evalcond[2]=((-1.0)+((x820*x823))+(((-1.0)*r02*x818*x819))+((r00*x824))+((r01*x822))+(((-1.0)*cj4*sj5*x818*x821)));
evalcond[3]=((((-1.0)*r02*x817*x819))+((x820*x822))+(((-1.0)*x821*x823))+(((-1.0)*r00*x825))+(((-1.0)*cj4*x821*x824)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x826=((12.0)*pz);
IkReal x827=((3.48732)*pz);
IkReal x828=(cj5*r10);
IkReal x829=((0.224)*sj4);
IkReal x830=(r21*sj5);
IkReal x831=((1.0510820652)*sj4);
IkReal x832=(cj4*r12);
IkReal x833=(r11*sj5);
IkReal x834=(cj5*r20);
IkReal x835=((1.16244)*sj4);
IkReal x836=(cj4*r22);
IkReal x837=((0.672)*sj4);
IkReal x838=((3.48732)*sj4);
IkReal x839=((0.3503606884)*sj4);
IkReal x840=((0.78)*x830);
IkReal x841=((0.04368)*x828);
IkReal x842=((0.2266758)*x830);
IkReal x843=(x830*x838);
IkReal x844=(x833*x837);
IkReal x845=(x830*x831);
IkReal x846=(x827+x841+x842+x845);
IkReal x847=(x826+x840+x843+x844);
IkReal x848=(((x831*x834))+(((0.672)*py))+(((1.0510820652)*x836))+(((0.04368)*x833))+(((0.2266758)*x834)));
IkReal x849=((((0.672)*x832))+(((0.78)*x834))+(((3.48732)*x836))+((x834*x838))+((x828*x837)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((-0.2006682)+(((-1.0)*x848))+x846)))))+(((2.72212543554007)*(IKabs(((0.2759322)+(((-1.0)*x848))+x846)))))+(((2.72212543554007)*(IKabs(((0.82)+(((-1.0)*x828*x829))+(((4.0)*pz))+(((-1.16244)*x836))+(((0.26)*x830))+(((-0.224)*x832))+(((-1.0)*x834*x835))+((x829*x833))+((x830*x835))+(((-0.26)*x834)))))))+(((2.72212543554007)*(IKabs(((0.2508442)+(((-0.3503606884)*x836))+(((-0.0755586)*x834))+(((-0.01456)*x833))+(((0.01456)*x828))+(((-1.0)*x834*x839))+(((-0.224)*py))+((x830*x839))+(((1.16244)*pz))+(((0.0755586)*x830)))))))+(((2.72212543554007)*(IKabs(((-0.82)+(((-1.0)*x849))+x847)))))+(((2.72212543554007)*(IKabs(((0.82)+(((-1.0)*x849))+x847))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x850=((12.0)*pz);
IkReal x851=((4.0)*pz);
IkReal x852=((0.224)*sj4);
IkReal x853=(r11*sj5);
IkReal x854=(cj5*r10);
IkReal x855=(cj5*r20);
IkReal x856=((1.16244)*sj4);
IkReal x857=(r21*sj5);
IkReal x858=(cj4*r22);
IkReal x859=(cj4*r12);
IkReal x860=((3.48732)*sj4);
IkReal x861=((0.672)*sj4);
IkReal x862=((0.78)*x857);
IkReal x863=((0.26)*x857);
IkReal x864=(x857*x860);
IkReal x865=(x853*x861);
IkReal x866=(x856*x857);
IkReal x867=(x852*x853);
IkReal x868=(x850+x865+x864+x862);
IkReal x869=(x851+x867+x866+x863);
IkReal x870=((((3.48732)*x858))+((x855*x860))+(((0.672)*x859))+((x854*x861))+(((0.78)*x855)));
IkReal x871=(((x855*x856))+(((0.224)*x859))+((x852*x854))+(((0.26)*x855))+(((1.16244)*x858)));
op[0]=((0.82)+x869+(((-1.0)*x871)));
op[1]=0;
op[2]=((0.82)+x868+(((-1.0)*x870)));
op[3]=0;
op[4]=((-0.82)+x868+(((-1.0)*x870)));
op[5]=0;
op[6]=((-0.82)+x869+(((-1.0)*x871)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x872=((3.48732)*pz);
IkReal x873=((1.16244)*pz);
IkReal x874=((0.224)*py);
IkReal x875=(cj5*r10);
IkReal x876=(r11*sj5);
IkReal x877=(r21*sj5);
IkReal x878=((1.0510820652)*sj4);
IkReal x879=(cj5*r20);
IkReal x880=(cj4*r22);
IkReal x881=((0.3503606884)*sj4);
IkReal x882=((0.0755586)*x877);
IkReal x883=((0.01456)*x875);
IkReal x884=((0.04368)*x875);
IkReal x885=((0.2266758)*x877);
IkReal x886=((0.3503606884)*x880);
IkReal x887=((0.0755586)*x879);
IkReal x888=((0.01456)*x876);
IkReal x889=(x877*x878);
IkReal x890=(x877*x881);
IkReal x891=(x879*x881);
IkReal x892=(x873+x883+x882+x890);
IkReal x893=(x872+x885+x884+x889);
IkReal x894=((((0.672)*py))+((x878*x879))+(((0.04368)*x876))+(((0.2266758)*x879))+(((1.0510820652)*x880)));
IkReal x895=(x874+x887+x886+x888+x891);
j1evalpoly[0]=((-0.2257562)+(((htj1*htj1*htj1*htj1)*(((0.2759322)+(((-1.0)*x894))+x893))))+(((-1.0)*x895))+(((-0.18368)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.2508442)+(((-1.0)*x895))+x892))))+(((-0.09184)*(htj1*htj1*htj1*htj1*htj1)))+x892+(((-0.09184)*htj1))+(((htj1*htj1)*(((-0.2006682)+(((-1.0)*x894))+x893)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x896=((1.0)*sj1);
IkReal x897=(cj4*r12);
IkReal x898=(sj4*sj5);
IkReal x899=((1.0)*cj1);
IkReal x900=(cj4*r22);
IkReal x901=(cj5*r20*sj4);
IkReal x902=(cj5*r10*sj4);
if( IKabs(((((-1.0)*x896*x901))+(((-1.0)*x896*x900))+(((-1.0)*x897*x899))+((r21*sj1*x898))+((cj1*r11*x898))+(((-1.0)*x899*x902)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x900))+((cj1*x901))+(((-1.0)*x896*x902))+(((-1.0)*x896*x897))+((r11*sj1*x898))+(((-1.0)*r21*x898*x899)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x896*x901))+(((-1.0)*x896*x900))+(((-1.0)*x897*x899))+((r21*sj1*x898))+((cj1*r11*x898))+(((-1.0)*x899*x902))))+IKsqr((((cj1*x900))+((cj1*x901))+(((-1.0)*x896*x902))+(((-1.0)*x896*x897))+((r11*sj1*x898))+(((-1.0)*r21*x898*x899))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x896*x901))+(((-1.0)*x896*x900))+(((-1.0)*x897*x899))+((r21*sj1*x898))+((cj1*r11*x898))+(((-1.0)*x899*x902))), (((cj1*x900))+((cj1*x901))+(((-1.0)*x896*x902))+(((-1.0)*x896*x897))+((r11*sj1*x898))+(((-1.0)*r21*x898*x899))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x903=IKcos(j2);
IkReal x904=IKsin(j2);
IkReal x905=(r11*sj5);
IkReal x906=((1.0)*sj4);
IkReal x907=(cj5*r10);
IkReal x908=(r21*sj5);
IkReal x909=(cj5*r20);
IkReal x910=((1.0)*sj3);
IkReal x911=((1.0)*cj4);
IkReal x912=(cj3*cj4);
IkReal x913=(cj1*x903);
IkReal x914=(sj1*x903);
IkReal x915=(cj1*x904);
IkReal x916=(sj1*x904);
IkReal x917=((1.0)*x916);
evalcond[0]=((((-1.0)*r22*x911))+(((-1.0)*x917))+((sj4*x908))+x913+(((-1.0)*x906*x909)));
evalcond[1]=((((-1.0)*r12*x911))+(((-1.0)*x914))+(((-1.0)*x915))+((sj4*x905))+(((-1.0)*x906*x907)));
evalcond[2]=((((-1.0)*r20*sj5*x910))+(((-1.0)*cj3*x908*x911))+((x909*x912))+(((-1.0)*cj3*r22*x906))+(((-1.0)*cj5*r21*x910))+x915+x914);
evalcond[3]=((((-1.0)*cj5*r11*x910))+(((-1.0)*cj3*x905*x911))+(((-1.0)*x917))+((x907*x912))+(((-1.0)*r10*sj5*x910))+x913+(((-1.0)*cj3*r12*x906)));
evalcond[4]=((((-0.29061)*x916))+(((0.205)*cj1))+(((-1.0)*pz))+(((0.065)*x909))+(((0.29061)*x913))+(((-0.056)*x914))+(((-0.056)*x915))+(((-0.065)*x908)));
evalcond[5]=((0.056)+(((-0.29061)*x915))+(((-0.29061)*x914))+(((-0.205)*sj1))+(((-1.0)*py))+(((0.056)*x916))+(((0.065)*x907))+(((-0.056)*x913))+(((-0.065)*x905)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x918=((1.0)*cj5);
CheckValue<IkReal> x919=IKPowWithIntegerCheck(IKsign(((((-1.0)*r10*sj4*x918))+((r11*sj4*sj5))+(((-1.0)*cj4*r12)))),-1);
if(!x919.valid){
continue;
}
CheckValue<IkReal> x920 = IKatan2WithCheck(IkReal((((cj5*r21))+((r20*sj5)))),IkReal((((cj4*r21*sj5))+(((-1.0)*cj4*r20*x918))+((r22*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x920.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x919.value)))+(x920.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x921=IKcos(j3);
IkReal x922=IKsin(j3);
IkReal x923=((1.0)*sj4);
IkReal x924=(cj4*r00);
IkReal x925=((1.0)*r01);
IkReal x926=(cj5*x921);
IkReal x927=(cj5*x922);
IkReal x928=(sj5*x921);
IkReal x929=((1.0)*sj5*x922);
evalcond[0]=(((cj4*r20*x927))+((r21*x926))+(((-1.0)*r22*x922*x923))+(((-1.0)*cj4*r21*x929))+((r20*x928)));
evalcond[1]=((((-1.0)*r12*x922*x923))+(((-1.0)*cj4*r11*x929))+((r10*x928))+((r11*x926))+((cj4*r10*x927)));
evalcond[2]=((-1.0)+(((-1.0)*r02*x922*x923))+((x924*x927))+(((-1.0)*cj4*sj5*x922*x925))+((r01*x926))+((r00*x928)));
evalcond[3]=((((-1.0)*x925*x927))+((x924*x926))+(((-1.0)*cj4*x925*x928))+(((-1.0)*r00*x929))+(((-1.0)*r02*x921*x923)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x930=((12.0)*pz);
IkReal x931=((3.48732)*pz);
IkReal x932=(cj5*r10);
IkReal x933=((0.224)*sj4);
IkReal x934=(r21*sj5);
IkReal x935=((1.0510820652)*sj4);
IkReal x936=(cj4*r12);
IkReal x937=(r11*sj5);
IkReal x938=(cj5*r20);
IkReal x939=((1.16244)*sj4);
IkReal x940=(cj4*r22);
IkReal x941=((0.672)*sj4);
IkReal x942=((3.48732)*sj4);
IkReal x943=((0.3503606884)*sj4);
IkReal x944=((0.78)*x934);
IkReal x945=((0.04368)*x932);
IkReal x946=((0.2266758)*x934);
IkReal x947=(x934*x942);
IkReal x948=(x937*x941);
IkReal x949=(x934*x935);
IkReal x950=(x931+x949+x945+x946);
IkReal x951=(x930+x948+x944+x947);
IkReal x952=((((0.672)*py))+(((0.04368)*x937))+(((0.2266758)*x938))+((x935*x938))+(((1.0510820652)*x940)));
IkReal x953=(((x932*x941))+(((0.78)*x938))+((x938*x942))+(((3.48732)*x940))+(((0.672)*x936)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((0.82)+(((-1.0)*x953))+x951)))))+(((2.72212543554007)*(IKabs(((0.2508442)+(((-0.3503606884)*x940))+(((-1.0)*x938*x943))+(((-0.01456)*x937))+(((-0.224)*py))+(((0.0755586)*x934))+((x934*x943))+(((0.01456)*x932))+(((1.16244)*pz))+(((-0.0755586)*x938)))))))+(((2.72212543554007)*(IKabs(((-0.82)+(((-1.0)*x953))+x951)))))+(((2.72212543554007)*(IKabs(((0.2759322)+(((-1.0)*x952))+x950)))))+(((2.72212543554007)*(IKabs(((0.82)+(((4.0)*pz))+(((-0.26)*x938))+(((-0.224)*x936))+(((0.26)*x934))+(((-1.0)*x938*x939))+(((-1.16244)*x940))+(((-1.0)*x932*x933))+((x934*x939))+((x933*x937)))))))+(((2.72212543554007)*(IKabs(((-0.2006682)+(((-1.0)*x952))+x950))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x954=((12.0)*pz);
IkReal x955=((4.0)*pz);
IkReal x956=((0.224)*sj4);
IkReal x957=(r11*sj5);
IkReal x958=(cj5*r10);
IkReal x959=(cj5*r20);
IkReal x960=((1.16244)*sj4);
IkReal x961=(r21*sj5);
IkReal x962=(cj4*r22);
IkReal x963=(cj4*r12);
IkReal x964=((3.48732)*sj4);
IkReal x965=((0.672)*sj4);
IkReal x966=((0.78)*x961);
IkReal x967=((0.26)*x961);
IkReal x968=(x961*x964);
IkReal x969=(x957*x965);
IkReal x970=(x960*x961);
IkReal x971=(x956*x957);
IkReal x972=(x966+x968+x969+x954);
IkReal x973=(x971+x970+x967+x955);
IkReal x974=((((3.48732)*x962))+(((0.672)*x963))+(((0.78)*x959))+((x959*x964))+((x958*x965)));
IkReal x975=((((0.224)*x963))+((x956*x958))+(((1.16244)*x962))+((x959*x960))+(((0.26)*x959)));
op[0]=((0.82)+x973+(((-1.0)*x975)));
op[1]=0;
op[2]=((0.82)+x972+(((-1.0)*x974)));
op[3]=0;
op[4]=((-0.82)+x972+(((-1.0)*x974)));
op[5]=0;
op[6]=((-0.82)+x973+(((-1.0)*x975)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x976=((3.48732)*pz);
IkReal x977=((1.16244)*pz);
IkReal x978=((0.224)*py);
IkReal x979=(cj5*r10);
IkReal x980=(r11*sj5);
IkReal x981=(r21*sj5);
IkReal x982=((1.0510820652)*sj4);
IkReal x983=(cj5*r20);
IkReal x984=(cj4*r22);
IkReal x985=((0.3503606884)*sj4);
IkReal x986=((0.0755586)*x981);
IkReal x987=((0.01456)*x979);
IkReal x988=((0.04368)*x979);
IkReal x989=((0.2266758)*x981);
IkReal x990=((0.3503606884)*x984);
IkReal x991=((0.0755586)*x983);
IkReal x992=((0.01456)*x980);
IkReal x993=(x981*x982);
IkReal x994=(x981*x985);
IkReal x995=(x983*x985);
IkReal x996=(x994+x986+x987+x977);
IkReal x997=(x993+x988+x989+x976);
IkReal x998=((((0.672)*py))+(((0.04368)*x980))+(((1.0510820652)*x984))+(((0.2266758)*x983))+((x982*x983)));
IkReal x999=(x992+x991+x990+x995+x978);
j1evalpoly[0]=((-0.2257562)+(((htj1*htj1*htj1*htj1)*(((0.2759322)+(((-1.0)*x998))+x997))))+(((-0.18368)*(htj1*htj1*htj1)))+(((htj1*htj1)*(((-0.2006682)+(((-1.0)*x998))+x997))))+(((-1.0)*x999))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.2508442)+(((-1.0)*x999))+x996))))+(((-0.09184)*(htj1*htj1*htj1*htj1*htj1)))+(((-0.09184)*htj1))+x996);
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1000=((1.0)*sj1);
IkReal x1001=(cj4*r12);
IkReal x1002=(sj4*sj5);
IkReal x1003=((1.0)*cj1);
IkReal x1004=(cj4*r22);
IkReal x1005=(cj5*r20*sj4);
IkReal x1006=(cj5*r10*sj4);
if( IKabs((((r21*sj1*x1002))+((cj1*r11*x1002))+(((-1.0)*x1001*x1003))+(((-1.0)*x1000*x1005))+(((-1.0)*x1000*x1004))+(((-1.0)*x1003*x1006)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r11*sj1*x1002))+((cj1*x1005))+((cj1*x1004))+(((-1.0)*r21*x1002*x1003))+(((-1.0)*x1000*x1006))+(((-1.0)*x1000*x1001)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r21*sj1*x1002))+((cj1*r11*x1002))+(((-1.0)*x1001*x1003))+(((-1.0)*x1000*x1005))+(((-1.0)*x1000*x1004))+(((-1.0)*x1003*x1006))))+IKsqr((((r11*sj1*x1002))+((cj1*x1005))+((cj1*x1004))+(((-1.0)*r21*x1002*x1003))+(((-1.0)*x1000*x1006))+(((-1.0)*x1000*x1001))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((r21*sj1*x1002))+((cj1*r11*x1002))+(((-1.0)*x1001*x1003))+(((-1.0)*x1000*x1005))+(((-1.0)*x1000*x1004))+(((-1.0)*x1003*x1006))), (((r11*sj1*x1002))+((cj1*x1005))+((cj1*x1004))+(((-1.0)*r21*x1002*x1003))+(((-1.0)*x1000*x1006))+(((-1.0)*x1000*x1001))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1007=IKcos(j2);
IkReal x1008=IKsin(j2);
IkReal x1009=(r11*sj5);
IkReal x1010=((1.0)*sj4);
IkReal x1011=(cj5*r10);
IkReal x1012=(r21*sj5);
IkReal x1013=(cj5*r20);
IkReal x1014=((1.0)*sj3);
IkReal x1015=((1.0)*cj4);
IkReal x1016=(cj3*cj4);
IkReal x1017=(cj1*x1007);
IkReal x1018=(sj1*x1007);
IkReal x1019=(cj1*x1008);
IkReal x1020=(sj1*x1008);
IkReal x1021=((1.0)*x1020);
evalcond[0]=((((-1.0)*r22*x1015))+(((-1.0)*x1010*x1013))+x1017+((sj4*x1012))+(((-1.0)*x1021)));
evalcond[1]=(((sj4*x1009))+(((-1.0)*x1010*x1011))+(((-1.0)*r12*x1015))+(((-1.0)*x1018))+(((-1.0)*x1019)));
evalcond[2]=(x1018+x1019+(((-1.0)*cj3*r22*x1010))+((x1013*x1016))+(((-1.0)*cj5*r21*x1014))+(((-1.0)*r20*sj5*x1014))+(((-1.0)*cj3*x1012*x1015)));
evalcond[3]=((((-1.0)*cj3*r12*x1010))+x1017+(((-1.0)*r10*sj5*x1014))+(((-1.0)*x1021))+(((-1.0)*cj5*r11*x1014))+((x1011*x1016))+(((-1.0)*cj3*x1009*x1015)));
evalcond[4]=((((0.205)*cj1))+(((-0.29061)*x1020))+(((0.065)*x1013))+(((-1.0)*pz))+(((0.29061)*x1017))+(((-0.056)*x1018))+(((-0.056)*x1019))+(((-0.065)*x1012)));
evalcond[5]=((0.056)+(((-0.065)*x1009))+(((0.056)*x1020))+(((-0.29061)*x1019))+(((-0.29061)*x1018))+(((-0.205)*sj1))+(((0.065)*x1011))+(((-1.0)*py))+(((-0.056)*x1017)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x1022 = IKatan2WithCheck(IkReal((((cj5*r11))+((r10*sj5)))),IkReal(((((-1.0)*cj4*cj5*r10))+((r12*sj4))+((cj4*r11*sj5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1022.valid){
continue;
}
CheckValue<IkReal> x1023=IKPowWithIntegerCheck(IKsign((((cj4*r22))+((cj5*r20*sj4))+(((-1.0)*r21*sj4*sj5)))),-1);
if(!x1023.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1022.value)+(((1.5707963267949)*(x1023.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1024=IKcos(j3);
IkReal x1025=IKsin(j3);
IkReal x1026=((1.0)*sj4);
IkReal x1027=(cj4*r00);
IkReal x1028=((1.0)*r01);
IkReal x1029=(cj5*x1024);
IkReal x1030=(cj5*x1025);
IkReal x1031=(sj5*x1024);
IkReal x1032=((1.0)*sj5*x1025);
evalcond[0]=(((r21*x1029))+((cj4*r20*x1030))+((r20*x1031))+(((-1.0)*cj4*r21*x1032))+(((-1.0)*r22*x1025*x1026)));
evalcond[1]=(((r10*x1031))+(((-1.0)*r12*x1025*x1026))+((r11*x1029))+(((-1.0)*cj4*r11*x1032))+((cj4*r10*x1030)));
evalcond[2]=((-1.0)+((r01*x1029))+((r00*x1031))+(((-1.0)*r02*x1025*x1026))+(((-1.0)*cj4*sj5*x1025*x1028))+((x1027*x1030)));
evalcond[3]=((((-1.0)*r02*x1024*x1026))+(((-1.0)*x1028*x1030))+((x1027*x1029))+(((-1.0)*r00*x1032))+(((-1.0)*cj4*x1028*x1031)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x1033=((12.0)*pz);
IkReal x1034=((3.48732)*pz);
IkReal x1035=(cj5*r10);
IkReal x1036=((0.224)*sj4);
IkReal x1037=(r21*sj5);
IkReal x1038=((1.0510820652)*sj4);
IkReal x1039=(cj4*r12);
IkReal x1040=(r11*sj5);
IkReal x1041=(cj5*r20);
IkReal x1042=((1.16244)*sj4);
IkReal x1043=(cj4*r22);
IkReal x1044=((0.672)*sj4);
IkReal x1045=((3.48732)*sj4);
IkReal x1046=((0.3503606884)*sj4);
IkReal x1047=((0.78)*x1037);
IkReal x1048=((0.04368)*x1035);
IkReal x1049=((0.2266758)*x1037);
IkReal x1050=(x1037*x1045);
IkReal x1051=(x1040*x1044);
IkReal x1052=(x1037*x1038);
IkReal x1053=(x1052+x1049+x1048+x1034);
IkReal x1054=(x1050+x1051+x1047+x1033);
IkReal x1055=(((x1038*x1041))+(((0.672)*py))+(((1.0510820652)*x1043))+(((0.04368)*x1040))+(((0.2266758)*x1041)));
IkReal x1056=((((0.78)*x1041))+((x1035*x1044))+((x1041*x1045))+(((3.48732)*x1043))+(((0.672)*x1039)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((0.82)+(((-1.0)*x1056))+x1054)))))+(((2.72212543554007)*(IKabs(((-0.2006682)+(((-1.0)*x1055))+x1053)))))+(((2.72212543554007)*(IKabs(((0.2759322)+(((-1.0)*x1055))+x1053)))))+(((2.72212543554007)*(IKabs(((0.2508442)+(((-0.01456)*x1040))+((x1037*x1046))+(((0.01456)*x1035))+(((-1.0)*x1041*x1046))+(((-0.224)*py))+(((-0.0755586)*x1041))+(((0.0755586)*x1037))+(((-0.3503606884)*x1043))+(((1.16244)*pz)))))))+(((2.72212543554007)*(IKabs(((-0.82)+(((-1.0)*x1056))+x1054)))))+(((2.72212543554007)*(IKabs(((0.82)+(((-1.16244)*x1043))+((x1037*x1042))+(((-1.0)*x1035*x1036))+(((4.0)*pz))+(((-0.26)*x1041))+(((-1.0)*x1041*x1042))+((x1036*x1040))+(((0.26)*x1037))+(((-0.224)*x1039))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1057=((12.0)*pz);
IkReal x1058=((4.0)*pz);
IkReal x1059=((0.224)*sj4);
IkReal x1060=(r11*sj5);
IkReal x1061=(cj5*r10);
IkReal x1062=(cj5*r20);
IkReal x1063=((1.16244)*sj4);
IkReal x1064=(r21*sj5);
IkReal x1065=(cj4*r22);
IkReal x1066=(cj4*r12);
IkReal x1067=((3.48732)*sj4);
IkReal x1068=((0.672)*sj4);
IkReal x1069=((0.78)*x1064);
IkReal x1070=((0.26)*x1064);
IkReal x1071=(x1064*x1067);
IkReal x1072=(x1060*x1068);
IkReal x1073=(x1063*x1064);
IkReal x1074=(x1059*x1060);
IkReal x1075=(x1057+x1072+x1071+x1069);
IkReal x1076=(x1058+x1074+x1073+x1070);
IkReal x1077=((((0.78)*x1062))+((x1061*x1068))+(((0.672)*x1066))+((x1062*x1067))+(((3.48732)*x1065)));
IkReal x1078=((((0.26)*x1062))+(((0.224)*x1066))+((x1062*x1063))+((x1059*x1061))+(((1.16244)*x1065)));
op[0]=((0.82)+x1076+(((-1.0)*x1078)));
op[1]=0;
op[2]=((0.82)+x1075+(((-1.0)*x1077)));
op[3]=0;
op[4]=((-0.82)+x1075+(((-1.0)*x1077)));
op[5]=0;
op[6]=((-0.82)+x1076+(((-1.0)*x1078)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1079=((3.48732)*pz);
IkReal x1080=((1.16244)*pz);
IkReal x1081=((0.224)*py);
IkReal x1082=(cj5*r10);
IkReal x1083=(r11*sj5);
IkReal x1084=(r21*sj5);
IkReal x1085=((1.0510820652)*sj4);
IkReal x1086=(cj5*r20);
IkReal x1087=(cj4*r22);
IkReal x1088=((0.3503606884)*sj4);
IkReal x1089=((0.0755586)*x1084);
IkReal x1090=((0.01456)*x1082);
IkReal x1091=((0.04368)*x1082);
IkReal x1092=((0.2266758)*x1084);
IkReal x1093=((0.3503606884)*x1087);
IkReal x1094=((0.0755586)*x1086);
IkReal x1095=((0.01456)*x1083);
IkReal x1096=(x1084*x1085);
IkReal x1097=(x1084*x1088);
IkReal x1098=(x1086*x1088);
IkReal x1099=(x1097+x1090+x1080+x1089);
IkReal x1100=(x1079+x1096+x1091+x1092);
IkReal x1101=((((0.672)*py))+(((1.0510820652)*x1087))+(((0.2266758)*x1086))+((x1085*x1086))+(((0.04368)*x1083)));
IkReal x1102=(x1094+x1095+x1093+x1098+x1081);
j1evalpoly[0]=((-0.2257562)+(((htj1*htj1)*(((-0.2006682)+x1100+(((-1.0)*x1101))))))+x1099+(((htj1*htj1*htj1*htj1)*(((0.2759322)+x1100+(((-1.0)*x1101))))))+(((-0.18368)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.2508442)+x1099+(((-1.0)*x1102))))))+(((-0.09184)*(htj1*htj1*htj1*htj1*htj1)))+(((-0.09184)*htj1))+(((-1.0)*x1102)));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1103=((1.0)*sj1);
IkReal x1104=(cj4*r12);
IkReal x1105=(sj4*sj5);
IkReal x1106=((1.0)*cj1);
IkReal x1107=(cj4*r22);
IkReal x1108=(cj5*r20*sj4);
IkReal x1109=(cj5*r10*sj4);
if( IKabs(((((-1.0)*x1103*x1108))+(((-1.0)*x1103*x1107))+((cj1*r11*x1105))+(((-1.0)*x1106*x1109))+(((-1.0)*x1104*x1106))+((r21*sj1*x1105)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1103*x1109))+(((-1.0)*x1103*x1104))+((r11*sj1*x1105))+((cj1*x1107))+((cj1*x1108))+(((-1.0)*r21*x1105*x1106)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1103*x1108))+(((-1.0)*x1103*x1107))+((cj1*r11*x1105))+(((-1.0)*x1106*x1109))+(((-1.0)*x1104*x1106))+((r21*sj1*x1105))))+IKsqr(((((-1.0)*x1103*x1109))+(((-1.0)*x1103*x1104))+((r11*sj1*x1105))+((cj1*x1107))+((cj1*x1108))+(((-1.0)*r21*x1105*x1106))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1103*x1108))+(((-1.0)*x1103*x1107))+((cj1*r11*x1105))+(((-1.0)*x1106*x1109))+(((-1.0)*x1104*x1106))+((r21*sj1*x1105))), ((((-1.0)*x1103*x1109))+(((-1.0)*x1103*x1104))+((r11*sj1*x1105))+((cj1*x1107))+((cj1*x1108))+(((-1.0)*r21*x1105*x1106))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1110=IKcos(j2);
IkReal x1111=IKsin(j2);
IkReal x1112=(r11*sj5);
IkReal x1113=((1.0)*sj4);
IkReal x1114=(cj5*r10);
IkReal x1115=(r21*sj5);
IkReal x1116=(cj5*r20);
IkReal x1117=((1.0)*sj3);
IkReal x1118=((1.0)*cj4);
IkReal x1119=(cj3*cj4);
IkReal x1120=(cj1*x1110);
IkReal x1121=(sj1*x1110);
IkReal x1122=(cj1*x1111);
IkReal x1123=(sj1*x1111);
IkReal x1124=((1.0)*x1123);
evalcond[0]=(x1120+(((-1.0)*r22*x1118))+(((-1.0)*x1113*x1116))+((sj4*x1115))+(((-1.0)*x1124)));
evalcond[1]=((((-1.0)*r12*x1118))+(((-1.0)*x1113*x1114))+((sj4*x1112))+(((-1.0)*x1121))+(((-1.0)*x1122)));
evalcond[2]=((((-1.0)*cj3*x1115*x1118))+x1121+x1122+(((-1.0)*cj3*r22*x1113))+(((-1.0)*r20*sj5*x1117))+((x1116*x1119))+(((-1.0)*cj5*r21*x1117)));
evalcond[3]=(((x1114*x1119))+x1120+(((-1.0)*cj3*x1112*x1118))+(((-1.0)*cj5*r11*x1117))+(((-1.0)*r10*sj5*x1117))+(((-1.0)*x1124))+(((-1.0)*cj3*r12*x1113)));
evalcond[4]=((((0.205)*cj1))+(((0.065)*x1116))+(((-0.065)*x1115))+(((0.29061)*x1120))+(((-1.0)*pz))+(((-0.056)*x1121))+(((-0.056)*x1122))+(((-0.29061)*x1123)));
evalcond[5]=((0.056)+(((0.065)*x1114))+(((-0.065)*x1112))+(((-0.205)*sj1))+(((-1.0)*py))+(((-0.056)*x1120))+(((-0.29061)*x1122))+(((-0.29061)*x1121))+(((0.056)*x1123)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1125=(((cj5*r10*sj4))+(((-1.0)*r11*sj4*sj5))+((cj4*r12)));
j3eval[0]=x1125;
j3eval[1]=IKsign(x1125);
j3eval[2]=((IKabs((((cj5*r21))+((r20*sj5)))))+(IKabs((((cj4*r21*sj5))+((r22*sj4))+(((-1.0)*cj4*cj5*r20))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1126=((1.0)*cj5);
IkReal x1127=(((r21*sj4*sj5))+(((-1.0)*r20*sj4*x1126))+(((-1.0)*cj4*r22)));
j3eval[0]=x1127;
j3eval[1]=((IKabs((((r12*sj4))+((cj4*r11*sj5))+(((-1.0)*cj4*r10*x1126)))))+(IKabs((((cj5*r11))+((r10*sj5))))));
j3eval[2]=IKsign(x1127);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1128=cj4*cj4;
IkReal x1129=cj5*cj5;
IkReal x1130=r01*r01;
IkReal x1131=r02*r02;
IkReal x1132=r00*r00;
IkReal x1133=(r00*sj5);
IkReal x1134=((2.0)*cj5);
IkReal x1135=(r02*sj4);
IkReal x1136=(cj4*r00);
IkReal x1137=((1.0)*x1128);
IkReal x1138=(cj4*r01*sj5);
IkReal x1139=(x1129*x1132);
IkReal x1140=(x1129*x1130);
IkReal x1141=(((x1134*x1135*x1136))+((x1128*x1140))+x1139+(((-2.0)*x1135*x1138))+(((-1.0)*x1130*x1137))+(((-1.0)*r01*x1133*x1134))+(((-1.0)*x1140))+((x1128*x1131))+(((-1.0)*x1132))+(((-1.0)*x1131))+(((-1.0)*x1137*x1139))+((r01*x1128*x1133*x1134)));
j3eval[0]=x1141;
j3eval[1]=((IKabs((((cj5*x1136))+(((-1.0)*x1135))+(((-1.0)*x1138)))))+(IKabs((x1133+((cj5*r01))))));
j3eval[2]=IKsign(x1141);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1142=cj4*cj4;
IkReal x1143=cj5*cj5;
IkReal x1144=r01*r01;
IkReal x1145=r02*r02;
IkReal x1146=r00*r00;
IkReal x1147=(r00*sj5);
IkReal x1148=((2.0)*cj5);
IkReal x1149=(r02*sj4);
IkReal x1150=(cj4*r00);
IkReal x1151=((1.0)*x1142);
IkReal x1152=(cj4*r01*sj5);
IkReal x1153=(x1143*x1146);
IkReal x1154=(x1143*x1144);
CheckValue<IkReal> x1155 = IKatan2WithCheck(IkReal(((((-1.0)*x1149))+(((-1.0)*x1152))+((cj5*x1150)))),IkReal((x1147+((cj5*r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1155.valid){
continue;
}
CheckValue<IkReal> x1156=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1144*x1151))+x1153+((x1142*x1154))+((x1142*x1145))+(((-2.0)*x1149*x1152))+(((-1.0)*r01*x1147*x1148))+(((-1.0)*x1145))+(((-1.0)*x1146))+(((-1.0)*x1154))+((r01*x1142*x1147*x1148))+(((-1.0)*x1151*x1153))+((x1148*x1149*x1150)))),-1);
if(!x1156.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1155.value)+(((1.5707963267949)*(x1156.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1157=IKcos(j3);
IkReal x1158=IKsin(j3);
IkReal x1159=((1.0)*sj4);
IkReal x1160=(cj4*r00);
IkReal x1161=((1.0)*r01);
IkReal x1162=(cj5*x1157);
IkReal x1163=(cj5*x1158);
IkReal x1164=(sj5*x1157);
IkReal x1165=((1.0)*sj5*x1158);
evalcond[0]=(((cj4*r20*x1163))+((r20*x1164))+((r21*x1162))+(((-1.0)*r22*x1158*x1159))+(((-1.0)*cj4*r21*x1165)));
evalcond[1]=((((-1.0)*cj4*r11*x1165))+((r10*x1164))+((cj4*r10*x1163))+((r11*x1162))+(((-1.0)*r12*x1158*x1159)));
evalcond[2]=((1.0)+(((-1.0)*r02*x1158*x1159))+((r00*x1164))+((r01*x1162))+((x1160*x1163))+(((-1.0)*cj4*sj5*x1158*x1161)));
evalcond[3]=((((-1.0)*r02*x1157*x1159))+(((-1.0)*r00*x1165))+(((-1.0)*x1161*x1163))+((x1160*x1162))+(((-1.0)*cj4*x1161*x1164)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1166=(cj5*r10);
IkReal x1167=((0.224)*sj4);
IkReal x1168=(r21*sj5);
IkReal x1169=((1.0510820652)*sj4);
IkReal x1170=(cj4*r12);
IkReal x1171=(r11*sj5);
IkReal x1172=((3.48732)*sj4);
IkReal x1173=(cj5*r20);
IkReal x1174=(cj4*r22);
IkReal x1175=((0.672)*sj4);
IkReal x1176=((1.16244)*sj4);
IkReal x1177=((0.3503606884)*sj4);
IkReal x1178=((3.48732)*x1174);
IkReal x1179=((0.78)*x1173);
IkReal x1180=((0.2266758)*x1173);
IkReal x1181=((0.04368)*x1166);
IkReal x1182=((1.0510820652)*x1174);
IkReal x1183=(x1172*x1173);
IkReal x1184=(x1171*x1175);
IkReal x1185=(x1169*x1173);
IkReal x1186=(x1185+x1182+x1180+x1181);
IkReal x1187=(((x1168*x1169))+(((0.672)*py))+(((0.04368)*x1171))+(((0.2266758)*x1168))+(((3.48732)*pz)));
IkReal x1188=(x1184+x1183+x1179+x1178);
IkReal x1189=((((0.78)*x1168))+(((12.0)*pz))+((x1166*x1175))+((x1168*x1172))+(((0.672)*x1170)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((0.2006682)+x1186+(((-1.0)*x1187)))))))+(((2.72212543554007)*(IKabs(((-0.2508442)+(((-0.01456)*x1171))+(((0.01456)*x1166))+(((-1.16244)*pz))+(((-1.0)*x1168*x1177))+((x1173*x1177))+(((0.0755586)*x1173))+(((-0.0755586)*x1168))+(((-0.224)*py))+(((0.3503606884)*x1174)))))))+(((2.72212543554007)*(IKabs(((-0.2759322)+x1186+(((-1.0)*x1187)))))))+(((2.72212543554007)*(IKabs(((-0.82)+(((-1.0)*x1166*x1167))+(((-0.26)*x1168))+(((-1.0)*x1168*x1176))+((x1173*x1176))+(((0.26)*x1173))+(((1.16244)*x1174))+(((-0.224)*x1170))+((x1167*x1171))+(((-4.0)*pz)))))))+(((2.72212543554007)*(IKabs(((-0.82)+x1188+(((-1.0)*x1189)))))))+(((2.72212543554007)*(IKabs(((0.82)+x1188+(((-1.0)*x1189))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1190=(cj4*r22);
IkReal x1191=(cj5*sj4);
IkReal x1192=(r21*sj5);
IkReal x1193=(cj4*r12);
IkReal x1194=(cj5*r20);
IkReal x1195=((3.48732)*x1190);
IkReal x1196=((0.78)*x1194);
IkReal x1197=((1.16244)*x1190);
IkReal x1198=((0.26)*x1194);
IkReal x1199=(r11*sj4*sj5);
IkReal x1200=((3.48732)*r20*x1191);
IkReal x1201=((0.672)*x1199);
IkReal x1202=((1.16244)*r20*x1191);
IkReal x1203=((0.224)*x1199);
IkReal x1204=(x1198+x1197+x1203+x1202);
IkReal x1205=(x1195+x1196+x1201+x1200);
IkReal x1206=((((12.0)*pz))+(((0.672)*r10*x1191))+(((3.48732)*sj4*x1192))+(((0.672)*x1193))+(((0.78)*x1192)));
IkReal x1207=((((0.224)*r10*x1191))+(((4.0)*pz))+(((0.26)*x1192))+(((1.16244)*sj4*x1192))+(((0.224)*x1193)));
op[0]=((-0.82)+x1204+(((-1.0)*x1207)));
op[1]=0;
op[2]=((-0.82)+x1205+(((-1.0)*x1206)));
op[3]=0;
op[4]=((0.82)+x1205+(((-1.0)*x1206)));
op[5]=0;
op[6]=((0.82)+x1204+(((-1.0)*x1207)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1208=(cj5*r10);
IkReal x1209=(r21*sj5);
IkReal x1210=((1.0510820652)*sj4);
IkReal x1211=(r11*sj5);
IkReal x1212=(cj5*r20);
IkReal x1213=(cj4*r22);
IkReal x1214=((0.3503606884)*sj4);
IkReal x1215=((0.3503606884)*x1213);
IkReal x1216=((0.01456)*x1208);
IkReal x1217=((0.2266758)*x1212);
IkReal x1218=((0.04368)*x1208);
IkReal x1219=((1.0510820652)*x1213);
IkReal x1220=((0.0755586)*x1212);
IkReal x1221=(x1210*x1212);
IkReal x1222=(x1212*x1214);
IkReal x1223=(x1222+x1220+x1216+x1215);
IkReal x1224=(x1221+x1217+x1218+x1219);
IkReal x1225=((((0.672)*py))+(((0.04368)*x1211))+(((0.2266758)*x1209))+((x1209*x1210))+(((3.48732)*pz)));
IkReal x1226=((((0.0755586)*x1209))+(((0.224)*py))+(((0.01456)*x1211))+((x1209*x1214))+(((1.16244)*pz)));
j1evalpoly[0]=((0.2257562)+x1223+(((htj1*htj1)*(((0.2006682)+x1224+(((-1.0)*x1225))))))+(((-1.0)*x1226))+(((0.09184)*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((-0.2759322)+x1224+(((-1.0)*x1225))))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.2508442)+x1223+(((-1.0)*x1226))))))+(((0.09184)*htj1))+(((0.18368)*(htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1227=(cj5*sj4);
IkReal x1228=(sj4*sj5);
IkReal x1229=((1.0)*sj1);
IkReal x1230=(cj4*r22);
IkReal x1231=((1.0)*cj1);
IkReal x1232=(cj4*r12);
if( IKabs(((((-1.0)*x1229*x1230))+((cj1*r10*x1227))+(((-1.0)*r11*x1228*x1231))+((cj1*x1232))+(((-1.0)*r20*x1227*x1229))+((r21*sj1*x1228)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r20*x1227))+((sj1*x1232))+(((-1.0)*r21*x1228*x1231))+((r10*sj1*x1227))+(((-1.0)*r11*x1228*x1229))+((cj1*x1230)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1229*x1230))+((cj1*r10*x1227))+(((-1.0)*r11*x1228*x1231))+((cj1*x1232))+(((-1.0)*r20*x1227*x1229))+((r21*sj1*x1228))))+IKsqr((((cj1*r20*x1227))+((sj1*x1232))+(((-1.0)*r21*x1228*x1231))+((r10*sj1*x1227))+(((-1.0)*r11*x1228*x1229))+((cj1*x1230))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1229*x1230))+((cj1*r10*x1227))+(((-1.0)*r11*x1228*x1231))+((cj1*x1232))+(((-1.0)*r20*x1227*x1229))+((r21*sj1*x1228))), (((cj1*r20*x1227))+((sj1*x1232))+(((-1.0)*r21*x1228*x1231))+((r10*sj1*x1227))+(((-1.0)*r11*x1228*x1229))+((cj1*x1230))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1233=IKcos(j2);
IkReal x1234=IKsin(j2);
IkReal x1235=(r11*sj5);
IkReal x1236=((1.0)*sj4);
IkReal x1237=(cj5*r10);
IkReal x1238=(r21*sj5);
IkReal x1239=(cj5*r20);
IkReal x1240=((1.0)*sj3);
IkReal x1241=((1.0)*cj4);
IkReal x1242=(cj3*cj4);
IkReal x1243=(sj1*x1233);
IkReal x1244=(cj1*x1234);
IkReal x1245=(cj1*x1233);
IkReal x1246=(sj1*x1234);
IkReal x1247=(x1243+x1244);
evalcond[0]=(x1247+(((-1.0)*r12*x1241))+(((-1.0)*x1236*x1237))+((sj4*x1235)));
evalcond[1]=(x1245+(((-1.0)*x1246))+(((-1.0)*x1236*x1239))+(((-1.0)*r22*x1241))+((sj4*x1238)));
evalcond[2]=((((-1.0)*r20*sj5*x1240))+x1247+((x1239*x1242))+(((-1.0)*cj3*r22*x1236))+(((-1.0)*cj5*r21*x1240))+(((-1.0)*cj3*x1238*x1241)));
evalcond[3]=(x1246+(((-1.0)*x1245))+(((-1.0)*cj3*r12*x1236))+(((-1.0)*r10*sj5*x1240))+(((-1.0)*cj5*r11*x1240))+(((-1.0)*cj3*x1235*x1241))+((x1237*x1242)));
evalcond[4]=((((-0.29061)*x1246))+(((0.205)*cj1))+(((-0.065)*x1238))+(((-1.0)*pz))+(((-0.056)*x1244))+(((-0.056)*x1243))+(((0.065)*x1239))+(((0.29061)*x1245)));
evalcond[5]=((-0.056)+(((0.056)*x1245))+(((-0.065)*x1235))+(((0.205)*sj1))+(((-1.0)*py))+(((-0.056)*x1246))+(((0.065)*x1237))+(((0.29061)*x1244))+(((0.29061)*x1243)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1248=((1.0)*cj4);
CheckValue<IkReal> x1249=IKPowWithIntegerCheck(IKsign((((r21*sj4*sj5))+(((-1.0)*cj5*r20*sj4))+(((-1.0)*r22*x1248)))),-1);
if(!x1249.valid){
continue;
}
CheckValue<IkReal> x1250 = IKatan2WithCheck(IkReal((((cj5*r11))+((r10*sj5)))),IkReal((((r12*sj4))+((cj4*r11*sj5))+(((-1.0)*cj5*r10*x1248)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1250.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1249.value)))+(x1250.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1251=IKcos(j3);
IkReal x1252=IKsin(j3);
IkReal x1253=((1.0)*sj4);
IkReal x1254=(cj4*r00);
IkReal x1255=((1.0)*r01);
IkReal x1256=(cj5*x1251);
IkReal x1257=(cj5*x1252);
IkReal x1258=(sj5*x1251);
IkReal x1259=((1.0)*sj5*x1252);
evalcond[0]=(((cj4*r20*x1257))+((r21*x1256))+(((-1.0)*r22*x1252*x1253))+((r20*x1258))+(((-1.0)*cj4*r21*x1259)));
evalcond[1]=(((r11*x1256))+((r10*x1258))+(((-1.0)*cj4*r11*x1259))+(((-1.0)*r12*x1252*x1253))+((cj4*r10*x1257)));
evalcond[2]=((1.0)+((x1254*x1257))+(((-1.0)*r02*x1252*x1253))+(((-1.0)*cj4*sj5*x1252*x1255))+((r00*x1258))+((r01*x1256)));
evalcond[3]=((((-1.0)*cj4*x1255*x1258))+(((-1.0)*r00*x1259))+(((-1.0)*x1255*x1257))+((x1254*x1256))+(((-1.0)*r02*x1251*x1253)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1260=(cj5*r10);
IkReal x1261=((0.224)*sj4);
IkReal x1262=(r21*sj5);
IkReal x1263=((1.0510820652)*sj4);
IkReal x1264=(cj4*r12);
IkReal x1265=(r11*sj5);
IkReal x1266=((3.48732)*sj4);
IkReal x1267=(cj5*r20);
IkReal x1268=(cj4*r22);
IkReal x1269=((0.672)*sj4);
IkReal x1270=((1.16244)*sj4);
IkReal x1271=((0.3503606884)*sj4);
IkReal x1272=((3.48732)*x1268);
IkReal x1273=((0.78)*x1267);
IkReal x1274=((0.2266758)*x1267);
IkReal x1275=((0.04368)*x1260);
IkReal x1276=((1.0510820652)*x1268);
IkReal x1277=(x1266*x1267);
IkReal x1278=(x1265*x1269);
IkReal x1279=(x1263*x1267);
IkReal x1280=(x1279+x1274+x1275+x1276);
IkReal x1281=((((0.672)*py))+(((0.04368)*x1265))+(((0.2266758)*x1262))+((x1262*x1263))+(((3.48732)*pz)));
IkReal x1282=(x1278+x1272+x1273+x1277);
IkReal x1283=((((12.0)*pz))+((x1260*x1269))+(((0.672)*x1264))+((x1262*x1266))+(((0.78)*x1262)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((-0.2759322)+x1280+(((-1.0)*x1281)))))))+(((2.72212543554007)*(IKabs(((0.2006682)+x1280+(((-1.0)*x1281)))))))+(((2.72212543554007)*(IKabs(((-0.2508442)+(((-0.0755586)*x1262))+(((-1.16244)*pz))+(((0.3503606884)*x1268))+(((0.0755586)*x1267))+(((-0.01456)*x1265))+((x1267*x1271))+(((0.01456)*x1260))+(((-0.224)*py))+(((-1.0)*x1262*x1271)))))))+(((2.72212543554007)*(IKabs(((-0.82)+x1282+(((-1.0)*x1283)))))))+(((2.72212543554007)*(IKabs(((-0.82)+(((-0.224)*x1264))+(((-1.0)*x1260*x1261))+((x1261*x1265))+(((1.16244)*x1268))+((x1267*x1270))+(((0.26)*x1267))+(((-0.26)*x1262))+(((-1.0)*x1262*x1270))+(((-4.0)*pz)))))))+(((2.72212543554007)*(IKabs(((0.82)+x1282+(((-1.0)*x1283))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1284=(cj4*r22);
IkReal x1285=(cj5*sj4);
IkReal x1286=(r21*sj5);
IkReal x1287=(cj4*r12);
IkReal x1288=(cj5*r20);
IkReal x1289=((3.48732)*x1284);
IkReal x1290=((0.78)*x1288);
IkReal x1291=((1.16244)*x1284);
IkReal x1292=((0.26)*x1288);
IkReal x1293=(r11*sj4*sj5);
IkReal x1294=((3.48732)*r20*x1285);
IkReal x1295=((0.672)*x1293);
IkReal x1296=((1.16244)*r20*x1285);
IkReal x1297=((0.224)*x1293);
IkReal x1298=(x1292+x1291+x1296+x1297);
IkReal x1299=(x1289+x1290+x1294+x1295);
IkReal x1300=((((12.0)*pz))+(((3.48732)*sj4*x1286))+(((0.78)*x1286))+(((0.672)*x1287))+(((0.672)*r10*x1285)));
IkReal x1301=((((0.224)*r10*x1285))+(((0.224)*x1287))+(((4.0)*pz))+(((1.16244)*sj4*x1286))+(((0.26)*x1286)));
op[0]=((-0.82)+x1298+(((-1.0)*x1301)));
op[1]=0;
op[2]=((-0.82)+x1299+(((-1.0)*x1300)));
op[3]=0;
op[4]=((0.82)+x1299+(((-1.0)*x1300)));
op[5]=0;
op[6]=((0.82)+x1298+(((-1.0)*x1301)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1302=(cj5*r10);
IkReal x1303=(r21*sj5);
IkReal x1304=((1.0510820652)*sj4);
IkReal x1305=(r11*sj5);
IkReal x1306=(cj5*r20);
IkReal x1307=(cj4*r22);
IkReal x1308=((0.3503606884)*sj4);
IkReal x1309=((0.3503606884)*x1307);
IkReal x1310=((0.01456)*x1302);
IkReal x1311=((0.2266758)*x1306);
IkReal x1312=((0.04368)*x1302);
IkReal x1313=((1.0510820652)*x1307);
IkReal x1314=((0.0755586)*x1306);
IkReal x1315=(x1304*x1306);
IkReal x1316=(x1306*x1308);
IkReal x1317=(x1309+x1316+x1314+x1310);
IkReal x1318=(x1315+x1313+x1312+x1311);
IkReal x1319=((((0.672)*py))+(((0.2266758)*x1303))+((x1303*x1304))+(((0.04368)*x1305))+(((3.48732)*pz)));
IkReal x1320=((((0.224)*py))+(((0.0755586)*x1303))+((x1303*x1308))+(((0.01456)*x1305))+(((1.16244)*pz)));
j1evalpoly[0]=((0.2257562)+x1317+(((-1.0)*x1320))+(((0.09184)*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1)*(((0.2006682)+x1318+(((-1.0)*x1319))))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.2508442)+x1317+(((-1.0)*x1320))))))+(((0.09184)*htj1))+(((htj1*htj1*htj1*htj1)*(((-0.2759322)+x1318+(((-1.0)*x1319))))))+(((0.18368)*(htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1321=(cj5*sj4);
IkReal x1322=(sj4*sj5);
IkReal x1323=((1.0)*sj1);
IkReal x1324=(cj4*r22);
IkReal x1325=((1.0)*cj1);
IkReal x1326=(cj4*r12);
if( IKabs(((((-1.0)*x1323*x1324))+((r21*sj1*x1322))+(((-1.0)*r20*x1321*x1323))+(((-1.0)*r11*x1322*x1325))+((cj1*r10*x1321))+((cj1*x1326)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r21*x1322*x1325))+(((-1.0)*r11*x1322*x1323))+((cj1*x1324))+((cj1*r20*x1321))+((r10*sj1*x1321))+((sj1*x1326)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1323*x1324))+((r21*sj1*x1322))+(((-1.0)*r20*x1321*x1323))+(((-1.0)*r11*x1322*x1325))+((cj1*r10*x1321))+((cj1*x1326))))+IKsqr(((((-1.0)*r21*x1322*x1325))+(((-1.0)*r11*x1322*x1323))+((cj1*x1324))+((cj1*r20*x1321))+((r10*sj1*x1321))+((sj1*x1326))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1323*x1324))+((r21*sj1*x1322))+(((-1.0)*r20*x1321*x1323))+(((-1.0)*r11*x1322*x1325))+((cj1*r10*x1321))+((cj1*x1326))), ((((-1.0)*r21*x1322*x1325))+(((-1.0)*r11*x1322*x1323))+((cj1*x1324))+((cj1*r20*x1321))+((r10*sj1*x1321))+((sj1*x1326))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1327=IKcos(j2);
IkReal x1328=IKsin(j2);
IkReal x1329=(r11*sj5);
IkReal x1330=((1.0)*sj4);
IkReal x1331=(cj5*r10);
IkReal x1332=(r21*sj5);
IkReal x1333=(cj5*r20);
IkReal x1334=((1.0)*sj3);
IkReal x1335=((1.0)*cj4);
IkReal x1336=(cj3*cj4);
IkReal x1337=(sj1*x1327);
IkReal x1338=(cj1*x1328);
IkReal x1339=(cj1*x1327);
IkReal x1340=(sj1*x1328);
IkReal x1341=(x1338+x1337);
evalcond[0]=(x1341+(((-1.0)*x1330*x1331))+((sj4*x1329))+(((-1.0)*r12*x1335)));
evalcond[1]=(x1339+((sj4*x1332))+(((-1.0)*r22*x1335))+(((-1.0)*x1330*x1333))+(((-1.0)*x1340)));
evalcond[2]=(x1341+(((-1.0)*cj3*r22*x1330))+(((-1.0)*cj3*x1332*x1335))+(((-1.0)*r20*sj5*x1334))+(((-1.0)*cj5*r21*x1334))+((x1333*x1336)));
evalcond[3]=(x1340+((x1331*x1336))+(((-1.0)*x1339))+(((-1.0)*cj3*x1329*x1335))+(((-1.0)*r10*sj5*x1334))+(((-1.0)*cj3*r12*x1330))+(((-1.0)*cj5*r11*x1334)));
evalcond[4]=((((0.205)*cj1))+(((0.29061)*x1339))+(((-1.0)*pz))+(((-0.065)*x1332))+(((-0.056)*x1338))+(((-0.056)*x1337))+(((-0.29061)*x1340))+(((0.065)*x1333)));
evalcond[5]=((-0.056)+(((0.056)*x1339))+(((0.29061)*x1337))+(((0.29061)*x1338))+(((0.205)*sj1))+(((-1.0)*py))+(((-0.065)*x1329))+(((0.065)*x1331))+(((-0.056)*x1340)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x1342=IKPowWithIntegerCheck(IKsign((((cj5*r10*sj4))+(((-1.0)*r11*sj4*sj5))+((cj4*r12)))),-1);
if(!x1342.valid){
continue;
}
CheckValue<IkReal> x1343 = IKatan2WithCheck(IkReal((((cj5*r21))+((r20*sj5)))),IkReal((((cj4*r21*sj5))+((r22*sj4))+(((-1.0)*cj4*cj5*r20)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1343.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1342.value)))+(x1343.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1344=IKcos(j3);
IkReal x1345=IKsin(j3);
IkReal x1346=((1.0)*sj4);
IkReal x1347=(cj4*r00);
IkReal x1348=((1.0)*r01);
IkReal x1349=(cj5*x1344);
IkReal x1350=(cj5*x1345);
IkReal x1351=(sj5*x1344);
IkReal x1352=((1.0)*sj5*x1345);
evalcond[0]=((((-1.0)*r22*x1345*x1346))+((cj4*r20*x1350))+((r20*x1351))+((r21*x1349))+(((-1.0)*cj4*r21*x1352)));
evalcond[1]=((((-1.0)*cj4*r11*x1352))+((r10*x1351))+((cj4*r10*x1350))+(((-1.0)*r12*x1345*x1346))+((r11*x1349)));
evalcond[2]=((1.0)+(((-1.0)*r02*x1345*x1346))+(((-1.0)*cj4*sj5*x1345*x1348))+((x1347*x1350))+((r01*x1349))+((r00*x1351)));
evalcond[3]=((((-1.0)*r02*x1344*x1346))+((x1347*x1349))+(((-1.0)*r00*x1352))+(((-1.0)*x1348*x1350))+(((-1.0)*cj4*x1348*x1351)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1353=(cj5*r10);
IkReal x1354=((0.224)*sj4);
IkReal x1355=(r21*sj5);
IkReal x1356=((1.0510820652)*sj4);
IkReal x1357=(cj4*r12);
IkReal x1358=(r11*sj5);
IkReal x1359=((3.48732)*sj4);
IkReal x1360=(cj5*r20);
IkReal x1361=(cj4*r22);
IkReal x1362=((0.672)*sj4);
IkReal x1363=((1.16244)*sj4);
IkReal x1364=((0.3503606884)*sj4);
IkReal x1365=((3.48732)*x1361);
IkReal x1366=((0.78)*x1360);
IkReal x1367=((0.2266758)*x1360);
IkReal x1368=((0.04368)*x1353);
IkReal x1369=((1.0510820652)*x1361);
IkReal x1370=(x1359*x1360);
IkReal x1371=(x1358*x1362);
IkReal x1372=(x1356*x1360);
IkReal x1373=(x1367+x1368+x1369+x1372);
IkReal x1374=(((x1355*x1356))+(((0.672)*py))+(((0.04368)*x1358))+(((0.2266758)*x1355))+(((3.48732)*pz)));
IkReal x1375=(x1366+x1365+x1371+x1370);
IkReal x1376=((((0.78)*x1355))+((x1355*x1359))+(((12.0)*pz))+(((0.672)*x1357))+((x1353*x1362)));
j1eval[0]=((1.0)+(((2.72212543554007)*(IKabs(((-0.2508442)+(((-0.0755586)*x1355))+(((-0.01456)*x1358))+(((0.01456)*x1353))+(((-1.16244)*pz))+(((0.0755586)*x1360))+((x1360*x1364))+(((-1.0)*x1355*x1364))+(((0.3503606884)*x1361))+(((-0.224)*py)))))))+(((2.72212543554007)*(IKabs(((-0.82)+(((0.26)*x1360))+((x1360*x1363))+((x1354*x1358))+(((-1.0)*x1355*x1363))+(((-0.224)*x1357))+(((1.16244)*x1361))+(((-4.0)*pz))+(((-0.26)*x1355))+(((-1.0)*x1353*x1354)))))))+(((2.72212543554007)*(IKabs(((0.82)+x1375+(((-1.0)*x1376)))))))+(((2.72212543554007)*(IKabs(((0.2006682)+x1373+(((-1.0)*x1374)))))))+(((2.72212543554007)*(IKabs(((-0.82)+x1375+(((-1.0)*x1376)))))))+(((2.72212543554007)*(IKabs(((-0.2759322)+x1373+(((-1.0)*x1374))))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1377=(cj4*r22);
IkReal x1378=(cj5*sj4);
IkReal x1379=(r21*sj5);
IkReal x1380=(cj4*r12);
IkReal x1381=(cj5*r20);
IkReal x1382=((3.48732)*x1377);
IkReal x1383=((0.78)*x1381);
IkReal x1384=((1.16244)*x1377);
IkReal x1385=((0.26)*x1381);
IkReal x1386=(r11*sj4*sj5);
IkReal x1387=((3.48732)*r20*x1378);
IkReal x1388=((0.672)*x1386);
IkReal x1389=((1.16244)*r20*x1378);
IkReal x1390=((0.224)*x1386);
IkReal x1391=(x1389+x1384+x1385+x1390);
IkReal x1392=(x1388+x1387+x1382+x1383);
IkReal x1393=((((12.0)*pz))+(((0.672)*x1380))+(((3.48732)*sj4*x1379))+(((0.78)*x1379))+(((0.672)*r10*x1378)));
IkReal x1394=((((0.26)*x1379))+(((0.224)*x1380))+(((4.0)*pz))+(((0.224)*r10*x1378))+(((1.16244)*sj4*x1379)));
op[0]=((-0.82)+x1391+(((-1.0)*x1394)));
op[1]=0;
op[2]=((-0.82)+x1392+(((-1.0)*x1393)));
op[3]=0;
op[4]=((0.82)+x1392+(((-1.0)*x1393)));
op[5]=0;
op[6]=((0.82)+x1391+(((-1.0)*x1394)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1395=(cj5*r10);
IkReal x1396=(r21*sj5);
IkReal x1397=((1.0510820652)*sj4);
IkReal x1398=(r11*sj5);
IkReal x1399=(cj5*r20);
IkReal x1400=(cj4*r22);
IkReal x1401=((0.3503606884)*sj4);
IkReal x1402=((0.3503606884)*x1400);
IkReal x1403=((0.01456)*x1395);
IkReal x1404=((0.2266758)*x1399);
IkReal x1405=((0.04368)*x1395);
IkReal x1406=((1.0510820652)*x1400);
IkReal x1407=((0.0755586)*x1399);
IkReal x1408=(x1397*x1399);
IkReal x1409=(x1399*x1401);
IkReal x1410=(x1409+x1403+x1402+x1407);
IkReal x1411=(x1408+x1406+x1405+x1404);
IkReal x1412=((((0.672)*py))+(((0.04368)*x1398))+((x1396*x1397))+(((0.2266758)*x1396))+(((3.48732)*pz)));
IkReal x1413=((((0.0755586)*x1396))+(((0.224)*py))+((x1396*x1401))+(((1.16244)*pz))+(((0.01456)*x1398)));
j1evalpoly[0]=((0.2257562)+(((htj1*htj1*htj1*htj1)*(((-0.2759322)+(((-1.0)*x1412))+x1411))))+(((-1.0)*x1413))+(((0.09184)*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1)*(((0.2006682)+(((-1.0)*x1412))+x1411))))+x1410+(((0.09184)*htj1))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.2508442)+(((-1.0)*x1413))+x1410))))+(((0.18368)*(htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1414=(cj5*sj4);
IkReal x1415=(sj4*sj5);
IkReal x1416=((1.0)*sj1);
IkReal x1417=(cj4*r22);
IkReal x1418=((1.0)*cj1);
IkReal x1419=(cj4*r12);
if( IKabs(((((-1.0)*r20*x1414*x1416))+((cj1*r10*x1414))+(((-1.0)*x1416*x1417))+((r21*sj1*x1415))+((cj1*x1419))+(((-1.0)*r11*x1415*x1418)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r20*x1414))+((r10*sj1*x1414))+(((-1.0)*r21*x1415*x1418))+((cj1*x1417))+((sj1*x1419))+(((-1.0)*r11*x1415*x1416)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r20*x1414*x1416))+((cj1*r10*x1414))+(((-1.0)*x1416*x1417))+((r21*sj1*x1415))+((cj1*x1419))+(((-1.0)*r11*x1415*x1418))))+IKsqr((((cj1*r20*x1414))+((r10*sj1*x1414))+(((-1.0)*r21*x1415*x1418))+((cj1*x1417))+((sj1*x1419))+(((-1.0)*r11*x1415*x1416))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*r20*x1414*x1416))+((cj1*r10*x1414))+(((-1.0)*x1416*x1417))+((r21*sj1*x1415))+((cj1*x1419))+(((-1.0)*r11*x1415*x1418))), (((cj1*r20*x1414))+((r10*sj1*x1414))+(((-1.0)*r21*x1415*x1418))+((cj1*x1417))+((sj1*x1419))+(((-1.0)*r11*x1415*x1416))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1420=IKcos(j2);
IkReal x1421=IKsin(j2);
IkReal x1422=(r11*sj5);
IkReal x1423=((1.0)*sj4);
IkReal x1424=(cj5*r10);
IkReal x1425=(r21*sj5);
IkReal x1426=(cj5*r20);
IkReal x1427=((1.0)*sj3);
IkReal x1428=((1.0)*cj4);
IkReal x1429=(cj3*cj4);
IkReal x1430=(sj1*x1420);
IkReal x1431=(cj1*x1421);
IkReal x1432=(cj1*x1420);
IkReal x1433=(sj1*x1421);
IkReal x1434=(x1430+x1431);
evalcond[0]=((((-1.0)*x1423*x1424))+((sj4*x1422))+(((-1.0)*r12*x1428))+x1434);
evalcond[1]=((((-1.0)*x1433))+(((-1.0)*x1423*x1426))+((sj4*x1425))+x1432+(((-1.0)*r22*x1428)));
evalcond[2]=((((-1.0)*cj3*x1425*x1428))+(((-1.0)*r20*sj5*x1427))+((x1426*x1429))+x1434+(((-1.0)*cj5*r21*x1427))+(((-1.0)*cj3*r22*x1423)));
evalcond[3]=(((x1424*x1429))+(((-1.0)*cj3*x1422*x1428))+(((-1.0)*x1432))+(((-1.0)*cj3*r12*x1423))+(((-1.0)*cj5*r11*x1427))+x1433+(((-1.0)*r10*sj5*x1427)));
evalcond[4]=((((0.205)*cj1))+(((-0.056)*x1430))+(((-0.056)*x1431))+(((0.065)*x1426))+(((-1.0)*pz))+(((-0.29061)*x1433))+(((0.29061)*x1432))+(((-0.065)*x1425)));
evalcond[5]=((-0.056)+(((-0.056)*x1433))+(((0.065)*x1424))+(((0.205)*sj1))+(((-1.0)*py))+(((0.056)*x1432))+(((0.29061)*x1431))+(((0.29061)*x1430))+(((-0.065)*x1422)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j2, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1435=(r10*sj0);
IkReal x1436=(cj0*r01);
IkReal x1437=(r11*sj0);
IkReal x1438=(cj0*r00);
IkReal x1439=(cj4*sj5);
IkReal x1440=((1.0)*cj4*cj5);
CheckValue<IkReal> x1441 = IKatan2WithCheck(IkReal((((sj5*x1438))+((sj5*x1435))+((cj5*x1437))+((cj5*x1436)))),IkReal((((x1436*x1439))+(((-1.0)*x1438*x1440))+((x1437*x1439))+((r12*sj0*sj4))+(((-1.0)*x1435*x1440))+((cj0*r02*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1441.valid){
continue;
}
CheckValue<IkReal> x1442=IKPowWithIntegerCheck(IKsign((((cj4*r22))+((cj5*r20*sj4))+(((-1.0)*r21*sj4*sj5)))),-1);
if(!x1442.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1441.value)+(((1.5707963267949)*(x1442.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1443=IKcos(j3);
IkReal x1444=IKsin(j3);
IkReal x1445=(cj5*x1443);
IkReal x1446=(sj5*x1443);
IkReal x1447=(cj4*cj5*x1444);
IkReal x1448=((1.0)*sj4*x1444);
IkReal x1449=((1.0)*cj4*sj5*x1444);
evalcond[0]=((((-1.0)*r22*x1448))+(((-1.0)*r21*x1449))+((r21*x1445))+((r20*x1447))+((r20*x1446)));
evalcond[1]=(((r10*x1447))+((r10*x1446))+((r11*x1445))+cj0+(((-1.0)*r12*x1448))+(((-1.0)*r11*x1449)));
evalcond[2]=((((-1.0)*sj0))+(((-1.0)*r01*x1449))+((r00*x1446))+((r00*x1447))+(((-1.0)*r02*x1448))+((r01*x1445)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1450=((0.82)*cj0);
IkReal x1451=((0.82)*sj0);
IkReal x1452=((3.48732)*sj4);
IkReal x1453=((0.224)*cj4);
IkReal x1454=((1.16244)*sj4);
IkReal x1455=(sj4*sj5);
IkReal x1456=((0.672)*cj4);
IkReal x1457=(pz*sj0);
IkReal x1458=(cj0*pz);
IkReal x1459=(r02*x1456);
IkReal x1460=((12.0)*x1458);
IkReal x1461=(r12*x1456);
IkReal x1462=((12.0)*x1457);
IkReal x1463=(cj5*r10*sj4);
IkReal x1464=(r21*sj0*sj5);
IkReal x1465=(cj0*cj5*r20);
IkReal x1466=((1.16244)*cj4*r22);
IkReal x1467=(cj0*r21*sj5);
IkReal x1468=(cj5*r20*sj0);
IkReal x1469=((3.48732)*cj4*r22);
IkReal x1470=(cj5*r00*sj4);
IkReal x1471=(cj0*x1469);
IkReal x1472=((0.672)*x1470);
IkReal x1473=((0.78)*x1465);
IkReal x1474=((0.78)*x1467);
IkReal x1475=((0.672)*r01*x1455);
IkReal x1476=((0.78)*x1468);
IkReal x1477=(sj0*x1469);
IkReal x1478=((0.672)*x1463);
IkReal x1479=((0.78)*x1464);
IkReal x1480=((0.672)*r11*x1455);
IkReal x1481=(x1452*x1465);
IkReal x1482=(x1452*x1467);
IkReal x1483=(x1452*x1468);
IkReal x1484=(x1452*x1464);
IkReal x1485=(x1460+x1474+x1475+x1482);
IkReal x1486=(x1462+x1479+x1480+x1484);
IkReal x1487=(x1459+x1472+x1473+x1471+x1481);
IkReal x1488=(x1461+x1476+x1477+x1478+x1483);
j1eval[0]=((IKabs(((((-0.224)*r11*x1455))+(((-1.0)*x1451))+(((0.26)*x1468))+(((-1.0)*x1454*x1464))+(((-4.0)*x1457))+((r12*x1453))+((x1454*x1468))+(((0.224)*x1463))+((sj0*x1466))+(((-0.26)*x1464)))))+(IKabs(((((-1.0)*x1486))+x1451+x1488)))+(IKabs(((((0.224)*x1470))+((cj0*x1466))+(((-1.0)*x1450))+(((0.26)*x1465))+(((-1.0)*x1454*x1467))+(((-4.0)*x1458))+((x1454*x1465))+(((-0.224)*r01*x1455))+((r02*x1453))+(((-0.26)*x1467)))))+(IKabs(((((-1.0)*x1486))+(((-1.0)*x1451))+x1488)))+(IKabs(((((-1.0)*x1485))+x1450+x1487)))+(IKabs(((((-1.0)*x1485))+(((-1.0)*x1450))+x1487))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1489=((0.82)*cj0);
IkReal x1490=(cj5*sj4);
IkReal x1491=(cj0*r20);
IkReal x1492=(sj4*sj5);
IkReal x1493=(cj0*r21);
IkReal x1494=(cj4*r02);
IkReal x1495=(cj0*pz);
IkReal x1496=((0.672)*x1494);
IkReal x1497=((12.0)*x1495);
IkReal x1498=((0.224)*x1494);
IkReal x1499=((4.0)*x1495);
IkReal x1500=(cj0*cj4*r22);
IkReal x1501=((3.48732)*x1500);
IkReal x1502=((0.672)*r00*x1490);
IkReal x1503=((0.78)*cj5*x1491);
IkReal x1504=((0.78)*sj5*x1493);
IkReal x1505=((0.672)*r01*x1492);
IkReal x1506=((1.16244)*x1500);
IkReal x1507=((0.26)*cj5*x1491);
IkReal x1508=((0.224)*r00*x1490);
IkReal x1509=((0.26)*sj5*x1493);
IkReal x1510=((0.224)*r01*x1492);
IkReal x1511=((3.48732)*x1490*x1491);
IkReal x1512=((3.48732)*x1492*x1493);
IkReal x1513=((1.16244)*x1490*x1491);
IkReal x1514=((1.16244)*x1492*x1493);
IkReal x1515=(x1504+x1505+x1512+x1497);
IkReal x1516=(x1509+x1514+x1510+x1499);
IkReal x1517=(x1502+x1503+x1501+x1511+x1496);
IkReal x1518=(x1506+x1507+x1508+x1513+x1498);
op[0]=((((-1.0)*x1516))+(((-1.0)*x1489))+x1518);
op[1]=0;
op[2]=((((-1.0)*x1515))+(((-1.0)*x1489))+x1517);
op[3]=0;
op[4]=((((-1.0)*x1515))+x1517+x1489);
op[5]=0;
op[6]=((((-1.0)*x1516))+x1518+x1489);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1519=((0.82)*sj0);
IkReal x1520=((3.48732)*sj4);
IkReal x1521=(cj4*r12);
IkReal x1522=((1.16244)*sj4);
IkReal x1523=(pz*sj0);
IkReal x1524=((0.224)*x1521);
IkReal x1525=((0.672)*x1521);
IkReal x1526=((12.0)*x1523);
IkReal x1527=((4.0)*x1523);
IkReal x1528=(cj5*r10*sj4);
IkReal x1529=(r21*sj0*sj5);
IkReal x1530=(cj5*r20*sj0);
IkReal x1531=(r11*sj4*sj5);
IkReal x1532=(cj4*r22*sj0);
IkReal x1533=((0.224)*x1528);
IkReal x1534=((1.16244)*x1532);
IkReal x1535=((0.26)*x1530);
IkReal x1536=((0.78)*x1530);
IkReal x1537=((3.48732)*x1532);
IkReal x1538=((0.672)*x1528);
IkReal x1539=((0.78)*x1529);
IkReal x1540=((0.672)*x1531);
IkReal x1541=((0.26)*x1529);
IkReal x1542=((0.224)*x1531);
IkReal x1543=(x1520*x1530);
IkReal x1544=(x1520*x1529);
IkReal x1545=(x1522*x1530);
IkReal x1546=(x1522*x1529);
IkReal x1547=(x1546+x1542+x1541+x1527);
IkReal x1548=(x1544+x1540+x1526+x1539);
IkReal x1549=(x1545+x1524+x1535+x1534+x1533);
IkReal x1550=(x1543+x1525+x1537+x1536+x1538);
j1evalpoly[0]=((((htj1*htj1)*((x1550+x1519+(((-1.0)*x1548))))))+(((htj1*htj1*htj1*htj1)*(((((-1.0)*x1519))+x1550+(((-1.0)*x1548))))))+x1549+x1519+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x1519))+x1549+(((-1.0)*x1547))))))+(((-1.0)*x1547)));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1551=(cj1*r20);
IkReal x1552=(sj3*sj5);
IkReal x1553=(cj5*sj4);
IkReal x1554=(cj1*r21);
IkReal x1555=(cj5*sj3);
IkReal x1556=((1.0)*sj1);
IkReal x1557=(cj4*r22);
IkReal x1558=(cj3*cj4);
IkReal x1559=(r21*sj1*sj5);
IkReal x1560=(cj3*r22*sj4);
if( IKabs((((x1551*x1552))+((sj4*x1559))+((cj1*x1560))+(((-1.0)*cj5*x1551*x1558))+((sj5*x1554*x1558))+((x1554*x1555))+(((-1.0)*r20*x1553*x1556))+(((-1.0)*x1556*x1557)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1551*x1553))+(((-1.0)*cj5*r20*x1556*x1558))+(((-1.0)*sj4*sj5*x1554))+((cj1*x1557))+((sj1*x1560))+((r20*sj1*x1552))+((x1558*x1559))+((r21*sj1*x1555)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1551*x1552))+((sj4*x1559))+((cj1*x1560))+(((-1.0)*cj5*x1551*x1558))+((sj5*x1554*x1558))+((x1554*x1555))+(((-1.0)*r20*x1553*x1556))+(((-1.0)*x1556*x1557))))+IKsqr((((x1551*x1553))+(((-1.0)*cj5*r20*x1556*x1558))+(((-1.0)*sj4*sj5*x1554))+((cj1*x1557))+((sj1*x1560))+((r20*sj1*x1552))+((x1558*x1559))+((r21*sj1*x1555))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x1551*x1552))+((sj4*x1559))+((cj1*x1560))+(((-1.0)*cj5*x1551*x1558))+((sj5*x1554*x1558))+((x1554*x1555))+(((-1.0)*r20*x1553*x1556))+(((-1.0)*x1556*x1557))), (((x1551*x1553))+(((-1.0)*cj5*r20*x1556*x1558))+(((-1.0)*sj4*sj5*x1554))+((cj1*x1557))+((sj1*x1560))+((r20*sj1*x1552))+((x1558*x1559))+((r21*sj1*x1555))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1561=IKsin(j2);
IkReal x1562=IKcos(j2);
IkReal x1563=((0.205)*sj1);
IkReal x1564=((0.065)*cj5);
IkReal x1565=(cj1*sj0);
IkReal x1566=(r11*sj5);
IkReal x1567=(r01*sj5);
IkReal x1568=(cj3*cj4);
IkReal x1569=(cj0*cj1);
IkReal x1570=(cj0*sj1);
IkReal x1571=(cj5*r00);
IkReal x1572=(r21*sj5);
IkReal x1573=((1.0)*cj4);
IkReal x1574=((0.056)*cj0);
IkReal x1575=(sj0*sj1);
IkReal x1576=((0.056)*sj0);
IkReal x1577=(cj1*x1562);
IkReal x1578=((0.29061)*x1561);
IkReal x1579=((1.0)*cj3*sj4);
IkReal x1580=(cj1*x1561);
IkReal x1581=((1.0)*x1561);
IkReal x1582=((1.0)*cj5*sj4);
IkReal x1583=((0.056)*x1561);
IkReal x1584=((1.0)*sj3*sj5);
IkReal x1585=(sj1*x1562);
IkReal x1586=((1.0)*cj5*sj3);
IkReal x1587=(x1562*x1575);
evalcond[0]=((((-1.0)*r22*x1573))+((sj4*x1572))+x1577+(((-1.0)*r20*x1582))+(((-1.0)*sj1*x1581)));
evalcond[1]=((((-1.0)*r02*x1573))+((sj4*x1567))+(((-1.0)*sj4*x1571))+(((-1.0)*x1569*x1581))+(((-1.0)*x1562*x1570)));
evalcond[2]=(((sj4*x1566))+(((-1.0)*x1587))+(((-1.0)*r12*x1573))+(((-1.0)*x1565*x1581))+(((-1.0)*r10*x1582)));
evalcond[3]=((((-1.0)*x1568*x1572))+((cj5*r20*x1568))+(((-1.0)*r22*x1579))+x1580+x1585+(((-1.0)*r20*x1584))+(((-1.0)*r21*x1586)));
evalcond[4]=((((-1.0)*sj1*x1578))+(((0.29061)*x1577))+((r20*x1564))+(((0.205)*cj1))+(((-0.056)*x1585))+(((-0.056)*x1580))+(((-1.0)*pz))+(((-0.065)*x1572)));
evalcond[5]=((((-1.0)*r02*x1579))+(((-1.0)*x1570*x1581))+(((-1.0)*r00*x1584))+(((-1.0)*r01*x1586))+((x1568*x1571))+(((-1.0)*x1567*x1568))+((x1562*x1569)));
evalcond[6]=((((-1.0)*r11*x1586))+((cj5*r10*x1568))+(((-1.0)*x1566*x1568))+((x1562*x1565))+(((-1.0)*r12*x1579))+(((-1.0)*x1575*x1581))+(((-1.0)*r10*x1584)));
evalcond[7]=((((-1.0)*cj0*x1563))+((x1570*x1583))+(((-0.056)*x1562*x1569))+(((-1.0)*px))+x1574+(((-1.0)*x1569*x1578))+(((-0.29061)*x1562*x1570))+((r00*x1564))+(((-0.065)*x1567)));
evalcond[8]=((((-1.0)*x1565*x1578))+((x1575*x1583))+(((-0.056)*x1562*x1565))+(((-1.0)*py))+x1576+(((-1.0)*sj0*x1563))+(((-0.29061)*x1587))+((r10*x1564))+(((-0.065)*x1566)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1588=(r21*sj0);
IkReal x1589=((1.0)*cj5);
IkReal x1590=(r20*sj0);
CheckValue<IkReal> x1591=IKPowWithIntegerCheck(IKsign((((r11*sj4*sj5))+(((-1.0)*cj4*r12))+(((-1.0)*r10*sj4*x1589)))),-1);
if(!x1591.valid){
continue;
}
CheckValue<IkReal> x1592 = IKatan2WithCheck(IkReal((((sj5*x1590))+((cj5*x1588)))),IkReal((((cj4*sj5*x1588))+((r22*sj0*sj4))+(((-1.0)*cj4*x1589*x1590)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1592.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1591.value)))+(x1592.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1593=IKcos(j3);
IkReal x1594=IKsin(j3);
IkReal x1595=(cj5*x1593);
IkReal x1596=(sj5*x1593);
IkReal x1597=(cj4*cj5*x1594);
IkReal x1598=((1.0)*sj4*x1594);
IkReal x1599=((1.0)*cj4*sj5*x1594);
evalcond[0]=(((r20*x1596))+((r20*x1597))+(((-1.0)*r22*x1598))+((r21*x1595))+(((-1.0)*r21*x1599)));
evalcond[1]=(cj0+((r11*x1595))+((r10*x1596))+((r10*x1597))+(((-1.0)*r12*x1598))+(((-1.0)*r11*x1599)));
evalcond[2]=(((r00*x1596))+((r00*x1597))+((r01*x1595))+(((-1.0)*sj0))+(((-1.0)*r02*x1598))+(((-1.0)*r01*x1599)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1600=((0.82)*cj0);
IkReal x1601=((0.82)*sj0);
IkReal x1602=((3.48732)*sj4);
IkReal x1603=((0.224)*cj4);
IkReal x1604=((1.16244)*sj4);
IkReal x1605=(sj4*sj5);
IkReal x1606=((0.672)*cj4);
IkReal x1607=(pz*sj0);
IkReal x1608=(cj0*pz);
IkReal x1609=(r02*x1606);
IkReal x1610=((12.0)*x1608);
IkReal x1611=(r12*x1606);
IkReal x1612=((12.0)*x1607);
IkReal x1613=(cj5*r10*sj4);
IkReal x1614=(r21*sj0*sj5);
IkReal x1615=(cj0*cj5*r20);
IkReal x1616=((1.16244)*cj4*r22);
IkReal x1617=(cj0*r21*sj5);
IkReal x1618=(cj5*r20*sj0);
IkReal x1619=((3.48732)*cj4*r22);
IkReal x1620=(cj5*r00*sj4);
IkReal x1621=(cj0*x1619);
IkReal x1622=((0.672)*x1620);
IkReal x1623=((0.78)*x1615);
IkReal x1624=((0.78)*x1617);
IkReal x1625=((0.672)*r01*x1605);
IkReal x1626=((0.78)*x1618);
IkReal x1627=(sj0*x1619);
IkReal x1628=((0.672)*x1613);
IkReal x1629=((0.78)*x1614);
IkReal x1630=((0.672)*r11*x1605);
IkReal x1631=(x1602*x1615);
IkReal x1632=(x1602*x1617);
IkReal x1633=(x1602*x1618);
IkReal x1634=(x1602*x1614);
IkReal x1635=(x1625+x1624+x1610+x1632);
IkReal x1636=(x1629+x1612+x1630+x1634);
IkReal x1637=(x1623+x1622+x1621+x1609+x1631);
IkReal x1638=(x1627+x1626+x1628+x1611+x1633);
j1eval[0]=((IKabs((x1600+x1637+(((-1.0)*x1635)))))+(IKabs(((((0.26)*x1618))+(((-1.0)*x1601))+((sj0*x1616))+(((-4.0)*x1607))+(((-0.224)*r11*x1605))+((r12*x1603))+((x1604*x1618))+(((-1.0)*x1604*x1614))+(((-0.26)*x1614))+(((0.224)*x1613)))))+(IKabs(((((-1.0)*x1600))+x1637+(((-1.0)*x1635)))))+(IKabs(((((-1.0)*x1601))+x1638+(((-1.0)*x1636)))))+(IKabs((x1601+x1638+(((-1.0)*x1636)))))+(IKabs(((((0.26)*x1615))+(((-1.0)*x1600))+((cj0*x1616))+(((-0.224)*r01*x1605))+(((-4.0)*x1608))+((x1604*x1615))+((r02*x1603))+(((0.224)*x1620))+(((-1.0)*x1604*x1617))+(((-0.26)*x1617))))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1639=((0.82)*cj0);
IkReal x1640=(cj5*sj4);
IkReal x1641=(cj0*r20);
IkReal x1642=(sj4*sj5);
IkReal x1643=(cj0*r21);
IkReal x1644=(cj4*r02);
IkReal x1645=(cj0*pz);
IkReal x1646=((0.672)*x1644);
IkReal x1647=((12.0)*x1645);
IkReal x1648=((0.224)*x1644);
IkReal x1649=((4.0)*x1645);
IkReal x1650=(cj0*cj4*r22);
IkReal x1651=((3.48732)*x1650);
IkReal x1652=((0.672)*r00*x1640);
IkReal x1653=((0.78)*cj5*x1641);
IkReal x1654=((0.78)*sj5*x1643);
IkReal x1655=((0.672)*r01*x1642);
IkReal x1656=((1.16244)*x1650);
IkReal x1657=((0.26)*cj5*x1641);
IkReal x1658=((0.224)*r00*x1640);
IkReal x1659=((0.26)*sj5*x1643);
IkReal x1660=((0.224)*r01*x1642);
IkReal x1661=((3.48732)*x1640*x1641);
IkReal x1662=((3.48732)*x1642*x1643);
IkReal x1663=((1.16244)*x1640*x1641);
IkReal x1664=((1.16244)*x1642*x1643);
IkReal x1665=(x1662+x1654+x1655+x1647);
IkReal x1666=(x1664+x1660+x1659+x1649);
IkReal x1667=(x1661+x1652+x1653+x1651+x1646);
IkReal x1668=(x1663+x1658+x1656+x1657+x1648);
op[0]=(x1668+(((-1.0)*x1639))+(((-1.0)*x1666)));
op[1]=0;
op[2]=(x1667+(((-1.0)*x1639))+(((-1.0)*x1665)));
op[3]=0;
op[4]=(x1667+x1639+(((-1.0)*x1665)));
op[5]=0;
op[6]=(x1668+x1639+(((-1.0)*x1666)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1669=((0.82)*sj0);
IkReal x1670=((3.48732)*sj4);
IkReal x1671=(cj4*r12);
IkReal x1672=((1.16244)*sj4);
IkReal x1673=(pz*sj0);
IkReal x1674=((0.224)*x1671);
IkReal x1675=((0.672)*x1671);
IkReal x1676=((12.0)*x1673);
IkReal x1677=((4.0)*x1673);
IkReal x1678=(cj5*r10*sj4);
IkReal x1679=(r21*sj0*sj5);
IkReal x1680=(cj5*r20*sj0);
IkReal x1681=(r11*sj4*sj5);
IkReal x1682=(cj4*r22*sj0);
IkReal x1683=((0.224)*x1678);
IkReal x1684=((1.16244)*x1682);
IkReal x1685=((0.26)*x1680);
IkReal x1686=((0.78)*x1680);
IkReal x1687=((3.48732)*x1682);
IkReal x1688=((0.672)*x1678);
IkReal x1689=((0.78)*x1679);
IkReal x1690=((0.672)*x1681);
IkReal x1691=((0.26)*x1679);
IkReal x1692=((0.224)*x1681);
IkReal x1693=(x1670*x1680);
IkReal x1694=(x1670*x1679);
IkReal x1695=(x1672*x1680);
IkReal x1696=(x1672*x1679);
IkReal x1697=(x1677+x1696+x1692+x1691);
IkReal x1698=(x1676+x1694+x1690+x1689);
IkReal x1699=(x1674+x1695+x1683+x1685+x1684);
IkReal x1700=(x1675+x1693+x1687+x1686+x1688);
j1evalpoly[0]=((((htj1*htj1)*(((((-1.0)*x1698))+x1700+x1669))))+(((-1.0)*x1697))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x1697))+x1699+(((-1.0)*x1669))))))+x1669+x1699+(((htj1*htj1*htj1*htj1)*(((((-1.0)*x1698))+x1700+(((-1.0)*x1669)))))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1701=(cj1*r20);
IkReal x1702=(sj3*sj5);
IkReal x1703=(cj5*sj4);
IkReal x1704=(cj1*r21);
IkReal x1705=(cj5*sj3);
IkReal x1706=((1.0)*sj1);
IkReal x1707=(cj4*r22);
IkReal x1708=(cj3*cj4);
IkReal x1709=(r21*sj1*sj5);
IkReal x1710=(cj3*r22*sj4);
if( IKabs((((sj4*x1709))+((cj1*x1710))+(((-1.0)*cj5*x1701*x1708))+((x1704*x1705))+((x1701*x1702))+((sj5*x1704*x1708))+(((-1.0)*x1706*x1707))+(((-1.0)*r20*x1703*x1706)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x1707))+((r21*sj1*x1705))+((x1701*x1703))+(((-1.0)*sj4*sj5*x1704))+(((-1.0)*cj5*r20*x1706*x1708))+((x1708*x1709))+((sj1*x1710))+((r20*sj1*x1702)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj4*x1709))+((cj1*x1710))+(((-1.0)*cj5*x1701*x1708))+((x1704*x1705))+((x1701*x1702))+((sj5*x1704*x1708))+(((-1.0)*x1706*x1707))+(((-1.0)*r20*x1703*x1706))))+IKsqr((((cj1*x1707))+((r21*sj1*x1705))+((x1701*x1703))+(((-1.0)*sj4*sj5*x1704))+(((-1.0)*cj5*r20*x1706*x1708))+((x1708*x1709))+((sj1*x1710))+((r20*sj1*x1702))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((sj4*x1709))+((cj1*x1710))+(((-1.0)*cj5*x1701*x1708))+((x1704*x1705))+((x1701*x1702))+((sj5*x1704*x1708))+(((-1.0)*x1706*x1707))+(((-1.0)*r20*x1703*x1706))), (((cj1*x1707))+((r21*sj1*x1705))+((x1701*x1703))+(((-1.0)*sj4*sj5*x1704))+(((-1.0)*cj5*r20*x1706*x1708))+((x1708*x1709))+((sj1*x1710))+((r20*sj1*x1702))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1711=IKsin(j2);
IkReal x1712=IKcos(j2);
IkReal x1713=((0.205)*sj1);
IkReal x1714=((0.065)*cj5);
IkReal x1715=(cj1*sj0);
IkReal x1716=(r11*sj5);
IkReal x1717=(r01*sj5);
IkReal x1718=(cj3*cj4);
IkReal x1719=(cj0*cj1);
IkReal x1720=(cj0*sj1);
IkReal x1721=(cj5*r00);
IkReal x1722=(r21*sj5);
IkReal x1723=((1.0)*cj4);
IkReal x1724=((0.056)*cj0);
IkReal x1725=(sj0*sj1);
IkReal x1726=((0.056)*sj0);
IkReal x1727=(cj1*x1712);
IkReal x1728=((0.29061)*x1711);
IkReal x1729=((1.0)*cj3*sj4);
IkReal x1730=(cj1*x1711);
IkReal x1731=((1.0)*x1711);
IkReal x1732=((1.0)*cj5*sj4);
IkReal x1733=((0.056)*x1711);
IkReal x1734=((1.0)*sj3*sj5);
IkReal x1735=(sj1*x1712);
IkReal x1736=((1.0)*cj5*sj3);
IkReal x1737=(x1712*x1725);
evalcond[0]=((((-1.0)*r22*x1723))+x1727+((sj4*x1722))+(((-1.0)*sj1*x1731))+(((-1.0)*r20*x1732)));
evalcond[1]=(((sj4*x1717))+(((-1.0)*x1712*x1720))+(((-1.0)*sj4*x1721))+(((-1.0)*x1719*x1731))+(((-1.0)*r02*x1723)));
evalcond[2]=(((sj4*x1716))+(((-1.0)*x1715*x1731))+(((-1.0)*r10*x1732))+(((-1.0)*r12*x1723))+(((-1.0)*x1737)));
evalcond[3]=((((-1.0)*r22*x1729))+x1730+x1735+((cj5*r20*x1718))+(((-1.0)*r21*x1736))+(((-1.0)*r20*x1734))+(((-1.0)*x1718*x1722)));
evalcond[4]=((((0.205)*cj1))+(((-0.056)*x1735))+(((-0.056)*x1730))+((r20*x1714))+(((-0.065)*x1722))+(((0.29061)*x1727))+(((-1.0)*pz))+(((-1.0)*sj1*x1728)));
evalcond[5]=(((x1712*x1719))+(((-1.0)*r01*x1736))+((x1718*x1721))+(((-1.0)*x1720*x1731))+(((-1.0)*r00*x1734))+(((-1.0)*x1717*x1718))+(((-1.0)*r02*x1729)));
evalcond[6]=((((-1.0)*x1716*x1718))+(((-1.0)*r11*x1736))+(((-1.0)*r10*x1734))+((cj5*r10*x1718))+((x1712*x1715))+(((-1.0)*r12*x1729))+(((-1.0)*x1725*x1731)));
evalcond[7]=((((-0.056)*x1712*x1719))+x1724+((x1720*x1733))+(((-1.0)*px))+((r00*x1714))+(((-1.0)*cj0*x1713))+(((-1.0)*x1719*x1728))+(((-0.065)*x1717))+(((-0.29061)*x1712*x1720)));
evalcond[8]=((((-0.056)*x1712*x1715))+(((-1.0)*x1715*x1728))+((x1725*x1733))+x1726+(((-0.29061)*x1737))+(((-1.0)*py))+(((-1.0)*sj0*x1713))+((r10*x1714))+(((-0.065)*x1716)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1738=((1.0)*cj5);
IkReal x1739=(cj0*r21);
IkReal x1740=(cj0*r20);
CheckValue<IkReal> x1741=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj4*r02))+((r01*sj4*sj5))+(((-1.0)*r00*sj4*x1738)))),-1);
if(!x1741.valid){
continue;
}
CheckValue<IkReal> x1742 = IKatan2WithCheck(IkReal((((cj5*x1739))+((sj5*x1740)))),IkReal((((cj4*sj5*x1739))+(((-1.0)*cj4*x1738*x1740))+((cj0*r22*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1742.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1741.value)))+(x1742.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1743=IKcos(j3);
IkReal x1744=IKsin(j3);
IkReal x1745=(cj5*x1743);
IkReal x1746=(sj5*x1743);
IkReal x1747=(cj4*cj5*x1744);
IkReal x1748=((1.0)*sj4*x1744);
IkReal x1749=((1.0)*cj4*sj5*x1744);
evalcond[0]=((((-1.0)*r22*x1748))+((r21*x1745))+((r20*x1747))+((r20*x1746))+(((-1.0)*r21*x1749)));
evalcond[1]=((((-1.0)*r12*x1748))+(((-1.0)*r11*x1749))+cj0+((r11*x1745))+((r10*x1747))+((r10*x1746)));
evalcond[2]=((((-1.0)*sj0))+(((-1.0)*r01*x1749))+((r00*x1747))+((r00*x1746))+((r01*x1745))+(((-1.0)*r02*x1748)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1750=((0.82)*cj0);
IkReal x1751=((0.82)*sj0);
IkReal x1752=((3.48732)*sj4);
IkReal x1753=((0.224)*cj4);
IkReal x1754=((1.16244)*sj4);
IkReal x1755=(sj4*sj5);
IkReal x1756=((0.672)*cj4);
IkReal x1757=(pz*sj0);
IkReal x1758=(cj0*pz);
IkReal x1759=(r02*x1756);
IkReal x1760=((12.0)*x1758);
IkReal x1761=(r12*x1756);
IkReal x1762=((12.0)*x1757);
IkReal x1763=(cj5*r10*sj4);
IkReal x1764=(r21*sj0*sj5);
IkReal x1765=(cj0*cj5*r20);
IkReal x1766=((1.16244)*cj4*r22);
IkReal x1767=(cj0*r21*sj5);
IkReal x1768=(cj5*r20*sj0);
IkReal x1769=((3.48732)*cj4*r22);
IkReal x1770=(cj5*r00*sj4);
IkReal x1771=(cj0*x1769);
IkReal x1772=((0.672)*x1770);
IkReal x1773=((0.78)*x1765);
IkReal x1774=((0.78)*x1767);
IkReal x1775=((0.672)*r01*x1755);
IkReal x1776=((0.78)*x1768);
IkReal x1777=(sj0*x1769);
IkReal x1778=((0.672)*x1763);
IkReal x1779=((0.78)*x1764);
IkReal x1780=((0.672)*r11*x1755);
IkReal x1781=(x1752*x1765);
IkReal x1782=(x1752*x1767);
IkReal x1783=(x1752*x1768);
IkReal x1784=(x1752*x1764);
IkReal x1785=(x1782+x1760+x1775+x1774);
IkReal x1786=(x1780+x1784+x1762+x1779);
IkReal x1787=(x1781+x1771+x1773+x1772+x1759);
IkReal x1788=(x1783+x1761+x1777+x1776+x1778);
j1eval[0]=((IKabs(((((-1.0)*x1785))+x1787+x1750)))+(IKabs(((((-1.0)*x1785))+x1787+(((-1.0)*x1750)))))+(IKabs((((sj0*x1766))+(((-1.0)*x1754*x1764))+(((0.26)*x1768))+((x1754*x1768))+(((-1.0)*x1751))+(((-0.26)*x1764))+(((-4.0)*x1757))+(((0.224)*x1763))+(((-0.224)*r11*x1755))+((r12*x1753)))))+(IKabs(((((-0.224)*r01*x1755))+(((-1.0)*x1754*x1767))+((r02*x1753))+((cj0*x1766))+(((0.224)*x1770))+(((0.26)*x1765))+((x1754*x1765))+(((-1.0)*x1750))+(((-0.26)*x1767))+(((-4.0)*x1758)))))+(IKabs(((((-1.0)*x1786))+x1788+(((-1.0)*x1751)))))+(IKabs(((((-1.0)*x1786))+x1788+x1751))));
if( IKabs(j1eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1789=((0.82)*cj0);
IkReal x1790=(cj5*sj4);
IkReal x1791=(cj0*r20);
IkReal x1792=(sj4*sj5);
IkReal x1793=(cj0*r21);
IkReal x1794=(cj4*r02);
IkReal x1795=(cj0*pz);
IkReal x1796=((0.672)*x1794);
IkReal x1797=((12.0)*x1795);
IkReal x1798=((0.224)*x1794);
IkReal x1799=((4.0)*x1795);
IkReal x1800=(cj0*cj4*r22);
IkReal x1801=((3.48732)*x1800);
IkReal x1802=((0.672)*r00*x1790);
IkReal x1803=((0.78)*cj5*x1791);
IkReal x1804=((0.78)*sj5*x1793);
IkReal x1805=((0.672)*r01*x1792);
IkReal x1806=((1.16244)*x1800);
IkReal x1807=((0.26)*cj5*x1791);
IkReal x1808=((0.224)*r00*x1790);
IkReal x1809=((0.26)*sj5*x1793);
IkReal x1810=((0.224)*r01*x1792);
IkReal x1811=((3.48732)*x1790*x1791);
IkReal x1812=((3.48732)*x1792*x1793);
IkReal x1813=((1.16244)*x1790*x1791);
IkReal x1814=((1.16244)*x1792*x1793);
IkReal x1815=(x1797+x1812+x1805+x1804);
IkReal x1816=(x1799+x1814+x1810+x1809);
IkReal x1817=(x1796+x1811+x1803+x1802+x1801);
IkReal x1818=(x1798+x1813+x1807+x1806+x1808);
op[0]=((((-1.0)*x1816))+(((-1.0)*x1789))+x1818);
op[1]=0;
op[2]=((((-1.0)*x1815))+(((-1.0)*x1789))+x1817);
op[3]=0;
op[4]=((((-1.0)*x1815))+x1789+x1817);
op[5]=0;
op[6]=((((-1.0)*x1816))+x1789+x1818);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1819=((0.82)*sj0);
IkReal x1820=((3.48732)*sj4);
IkReal x1821=(cj4*r12);
IkReal x1822=((1.16244)*sj4);
IkReal x1823=(pz*sj0);
IkReal x1824=((0.224)*x1821);
IkReal x1825=((0.672)*x1821);
IkReal x1826=((12.0)*x1823);
IkReal x1827=((4.0)*x1823);
IkReal x1828=(cj5*r10*sj4);
IkReal x1829=(r21*sj0*sj5);
IkReal x1830=(cj5*r20*sj0);
IkReal x1831=(r11*sj4*sj5);
IkReal x1832=(cj4*r22*sj0);
IkReal x1833=((0.224)*x1828);
IkReal x1834=((1.16244)*x1832);
IkReal x1835=((0.26)*x1830);
IkReal x1836=((0.78)*x1830);
IkReal x1837=((3.48732)*x1832);
IkReal x1838=((0.672)*x1828);
IkReal x1839=((0.78)*x1829);
IkReal x1840=((0.672)*x1831);
IkReal x1841=((0.26)*x1829);
IkReal x1842=((0.224)*x1831);
IkReal x1843=(x1820*x1830);
IkReal x1844=(x1820*x1829);
IkReal x1845=(x1822*x1830);
IkReal x1846=(x1822*x1829);
IkReal x1847=(x1827+x1842+x1841+x1846);
IkReal x1848=(x1826+x1840+x1844+x1839);
IkReal x1849=(x1824+x1845+x1833+x1834+x1835);
IkReal x1850=(x1825+x1843+x1836+x1837+x1838);
j1evalpoly[0]=((((htj1*htj1)*(((((-1.0)*x1848))+x1850+x1819))))+(((-1.0)*x1847))+(((htj1*htj1*htj1*htj1)*(((((-1.0)*x1819))+(((-1.0)*x1848))+x1850))))+x1849+x1819+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x1819))+(((-1.0)*x1847))+x1849)))));
if( IKabs(j1evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1851=(cj1*r20);
IkReal x1852=(sj3*sj5);
IkReal x1853=(cj5*sj4);
IkReal x1854=(cj1*r21);
IkReal x1855=(cj5*sj3);
IkReal x1856=((1.0)*sj1);
IkReal x1857=(cj4*r22);
IkReal x1858=(cj3*cj4);
IkReal x1859=(r21*sj1*sj5);
IkReal x1860=(cj3*r22*sj4);
if( IKabs((((cj1*x1860))+((sj5*x1854*x1858))+((x1851*x1852))+((sj4*x1859))+(((-1.0)*r20*x1853*x1856))+(((-1.0)*cj5*x1851*x1858))+(((-1.0)*x1856*x1857))+((x1854*x1855)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1851*x1853))+((cj1*x1857))+((r21*sj1*x1855))+(((-1.0)*cj5*r20*x1856*x1858))+((sj1*x1860))+((r20*sj1*x1852))+((x1858*x1859))+(((-1.0)*sj4*sj5*x1854)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*x1860))+((sj5*x1854*x1858))+((x1851*x1852))+((sj4*x1859))+(((-1.0)*r20*x1853*x1856))+(((-1.0)*cj5*x1851*x1858))+(((-1.0)*x1856*x1857))+((x1854*x1855))))+IKsqr((((x1851*x1853))+((cj1*x1857))+((r21*sj1*x1855))+(((-1.0)*cj5*r20*x1856*x1858))+((sj1*x1860))+((r20*sj1*x1852))+((x1858*x1859))+(((-1.0)*sj4*sj5*x1854))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj1*x1860))+((sj5*x1854*x1858))+((x1851*x1852))+((sj4*x1859))+(((-1.0)*r20*x1853*x1856))+(((-1.0)*cj5*x1851*x1858))+(((-1.0)*x1856*x1857))+((x1854*x1855))), (((x1851*x1853))+((cj1*x1857))+((r21*sj1*x1855))+(((-1.0)*cj5*r20*x1856*x1858))+((sj1*x1860))+((r20*sj1*x1852))+((x1858*x1859))+(((-1.0)*sj4*sj5*x1854))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1861=IKsin(j2);
IkReal x1862=IKcos(j2);
IkReal x1863=((0.205)*sj1);
IkReal x1864=((0.065)*cj5);
IkReal x1865=(cj1*sj0);
IkReal x1866=(r11*sj5);
IkReal x1867=(r01*sj5);
IkReal x1868=(cj3*cj4);
IkReal x1869=(cj0*cj1);
IkReal x1870=(cj0*sj1);
IkReal x1871=(cj5*r00);
IkReal x1872=(r21*sj5);
IkReal x1873=((1.0)*cj4);
IkReal x1874=((0.056)*cj0);
IkReal x1875=(sj0*sj1);
IkReal x1876=((0.056)*sj0);
IkReal x1877=(cj1*x1862);
IkReal x1878=((0.29061)*x1861);
IkReal x1879=((1.0)*cj3*sj4);
IkReal x1880=(cj1*x1861);
IkReal x1881=((1.0)*x1861);
IkReal x1882=((1.0)*cj5*sj4);
IkReal x1883=((0.056)*x1861);
IkReal x1884=((1.0)*sj3*sj5);
IkReal x1885=(sj1*x1862);
IkReal x1886=((1.0)*cj5*sj3);
IkReal x1887=(x1862*x1875);
evalcond[0]=((((-1.0)*r22*x1873))+x1877+(((-1.0)*r20*x1882))+((sj4*x1872))+(((-1.0)*sj1*x1881)));
evalcond[1]=(((sj4*x1867))+(((-1.0)*x1862*x1870))+(((-1.0)*x1869*x1881))+(((-1.0)*r02*x1873))+(((-1.0)*sj4*x1871)));
evalcond[2]=(((sj4*x1866))+(((-1.0)*r10*x1882))+(((-1.0)*x1865*x1881))+(((-1.0)*r12*x1873))+(((-1.0)*x1887)));
evalcond[3]=((((-1.0)*r22*x1879))+((cj5*r20*x1868))+x1885+x1880+(((-1.0)*r20*x1884))+(((-1.0)*r21*x1886))+(((-1.0)*x1868*x1872)));
evalcond[4]=((((0.205)*cj1))+(((-1.0)*sj1*x1878))+(((-1.0)*pz))+(((0.29061)*x1877))+(((-0.065)*x1872))+((r20*x1864))+(((-0.056)*x1880))+(((-0.056)*x1885)));
evalcond[5]=((((-1.0)*x1867*x1868))+(((-1.0)*r02*x1879))+(((-1.0)*x1870*x1881))+((x1862*x1869))+(((-1.0)*r00*x1884))+((x1868*x1871))+(((-1.0)*r01*x1886)));
evalcond[6]=((((-1.0)*x1866*x1868))+(((-1.0)*x1875*x1881))+((x1862*x1865))+(((-1.0)*r11*x1886))+((cj5*r10*x1868))+(((-1.0)*r10*x1884))+(((-1.0)*r12*x1879)));
evalcond[7]=((((-1.0)*cj0*x1863))+(((-1.0)*x1869*x1878))+((x1870*x1883))+(((-0.056)*x1862*x1869))+(((-0.065)*x1867))+(((-1.0)*px))+x1874+(((-0.29061)*x1862*x1870))+((r00*x1864)));
evalcond[8]=((((-0.056)*x1862*x1865))+(((-0.29061)*x1887))+(((-0.065)*x1866))+((x1875*x1883))+(((-1.0)*py))+x1876+((r10*x1864))+(((-1.0)*x1865*x1878))+(((-1.0)*sj0*x1863)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "0abffffc6855aed771f154a03ed601bd"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
